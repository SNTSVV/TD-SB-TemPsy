--
-- Copyright by University of Luxembourg 2020-2021. 
--   Developed by Chaima Boufaied, chaima.boufaied@uni.lu University of Luxembourg. 
--   Developed by Claudio Menghi, claudio.menghi@uni.lu University of Luxembourg. 
--   Developed by Domenico Bianculli, domenico.bianculli@uni.lu University of Luxembourg. 
--   Developed by Lionel Briand, lionel.briand@uni.lu University of Luxembourg. 
--

import 'platform:/resource/lu.svv.offline/models/sbtempsy.ecore#/'
import 'platform:/resource/lu.svv.offline/models/trace.ecore#/'
import 'platform:/resource/lu.svv.offline/models/check.ecore#/'
import 'platform:/resource/lu.svv.offline/models/diagnostics.ecore#/'


package check

context Monitor

------ ******************------
------ Utility functions
------ ******************------	
def: getInputTraceElements(trace:trace::Trace):OrderedSet(trace::TraceElement) = 
trace.traceElements

def: getValue(element:trace::TraceElement,signal:sBTemPsy::Signal):sBTemPsy::Value=
	element.signalValue->select(elem |  signal.id= elem.key.id) -> asSequence()->first().value

def: getValueOfBoundary(trace:OrderedSet(trace::TraceElement),signal:sBTemPsy::Signal,tl:Real):Real=
	trace->select(element | element.generationTime =tl   
	)->asSequence()->first().signalValue->select(elem | signal.id= elem.key.id ) -> asSequence()->first().value.val


def: getSignalName(element:trace::TraceElement,signal:sBTemPsy::Signal):String=
	element.signalValue->select(elem |  signal.id= elem.key.id ) -> asSequence()->first().key.id	

def: getPatternSignalName(pattern:sBTemPsy::SimplePattern):String=
	if pattern.oclIsTypeOf(sBTemPsy::Assertion) then 
		let daPattern:sBTemPsy::Assertion=pattern.oclAsType(sBTemPsy::Assertion) in 
			daPattern.signal.id
	else 
		if pattern.oclIsTypeOf(sBTemPsy::StateAssertion) then 
			let statePattern:sBTemPsy::StateAssertion=pattern.oclAsType(sBTemPsy::StateAssertion) in 
				statePattern.signal.id		
		else 
			if pattern.oclIsTypeOf(sBTemPsy::Spike) then 
				let spkPattern:sBTemPsy::Spike=pattern.oclAsType(sBTemPsy::Spike) in 
				spkPattern.signal.id
			else 
				if pattern.oclIsTypeOf(sBTemPsy::Oscillation) then 
					let oscPattern:sBTemPsy::Oscillation=pattern.oclAsType(sBTemPsy::Oscillation) in 
					oscPattern.signal.id
				else
					if pattern.oclIsTypeOf(sBTemPsy::Rise) then 
						let risePattern:sBTemPsy::Rise=pattern.oclAsType(sBTemPsy::Rise) in 
						risePattern.signal.id
					else
						if pattern.oclIsTypeOf(sBTemPsy::Fall) then 
							let fallPattern:sBTemPsy::Fall=pattern.oclAsType(sBTemPsy::Fall) in 
							fallPattern.signal.id
						else
							if pattern.oclIsTypeOf(sBTemPsy::Overshoot) then 
								let oshPattern:sBTemPsy::Overshoot=pattern.oclAsType(sBTemPsy::Overshoot) in 
								oshPattern.signal.id
							else
								let ushPattern:sBTemPsy::Undershoot=pattern.oclAsType(sBTemPsy::Undershoot) in 
								ushPattern.signal.id
							endif
						endif
					endif
				endif	 
			endif
		endif
	endif		

	
def: isInTimestamps(trace:OrderedSet(trace::TraceElement),punctualScBoundary:Real):Boolean=
	trace->exists(t:trace::TraceElement | t.generationTime=punctualScBoundary)


def: getTracePortion(trace:OrderedSet(trace::TraceElement),tl:Real,tu:Real):OrderedSet(trace::TraceElement) =
	trace->select(t:trace::TraceElement | t.generationTime >= tl and t.generationTime <= tu)



---------  Report Predicate  ---------
def: reportPredicate(trace:OrderedSet(trace::TraceElement), element:trace::TraceElement, assertion:sBTemPsy::Assertion): Boolean =
   		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::LESSEQ and
		 getValue(element, assertion.signal).val > assertion.dAPred.value.val ) or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::LESS and
		 getValue(element, assertion.signal).val >= assertion.dAPred.value.val ) or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::EQL and
		 getValue(element, assertion.signal).val <> assertion.dAPred.value.val ) or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::GRTEQ and
		 getValue(element, assertion.signal).val < assertion.dAPred.value.val )	or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::GRT and
		 getValue(element, assertion.signal).val <= assertion.dAPred.value.val ) or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::DIFF and
		 getValue(element, assertion.signal).val = assertion.dAPred.value.val )	


def: checkPredicate(trace:OrderedSet(trace::TraceElement), element:trace::TraceElement, assertion:sBTemPsy::Assertion): Boolean =
   		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::LESSEQ and
		 getValue(element, assertion.signal).val <= assertion.dAPred.value.val ) or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::LESS and
		 getValue(element, assertion.signal).val < assertion.dAPred.value.val ) or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::EQL and
		 getValue(element, assertion.signal).val = assertion.dAPred.value.val ) or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::GRTEQ and
		 getValue(element, assertion.signal).val >= assertion.dAPred.value.val )	or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::GRT and
		 getValue(element, assertion.signal).val > assertion.dAPred.value.val ) or
		 ( assertion.dAPred.rOp = sBTemPsy::RelationalOperator::DIFF and
		 getValue(element, assertion.signal).val <> assertion.dAPred.value.val )	


def: reportStateViolatedPredicate(element:trace::TraceElement, statePat:sBTemPsy::StateAssertion): Boolean = 
	 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::LESSEQ and
		 getValue(element, statePat.signal).val > statePat.dAPred.value.val ) or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::LESS and
		 getValue(element, statePat.signal).val >= statePat.dAPred.value.val ) or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::EQL and
		 getValue(element, statePat.signal).val <> statePat.dAPred.value.val ) or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::GRTEQ and
		 getValue(element, statePat.signal).val < statePat.dAPred.value.val )	or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::GRT and
		 getValue(element, statePat.signal).val <= statePat.dAPred.value.val ) or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::DIFF and
		 getValue(element, statePat.signal).val = statePat.dAPred.value.val )	
		

def: reportStateSatisfiedPredicate(element:trace::TraceElement, statePat:sBTemPsy::StateAssertion): Boolean = 
	 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::LESSEQ and
		 getValue(element, statePat.signal).val <= statePat.dAPred.value.val ) or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::LESS and
		 getValue(element, statePat.signal).val < statePat.dAPred.value.val ) or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::EQL and
		 getValue(element, statePat.signal).val = statePat.dAPred.value.val ) or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::GRTEQ and
		 getValue(element, statePat.signal).val >= statePat.dAPred.value.val )	or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::GRT and
		 getValue(element, statePat.signal).val > statePat.dAPred.value.val ) or
		 ( statePat.dAPred.rOp = sBTemPsy::RelationalOperator::DIFF and
		 getValue(element, statePat.signal).val <> statePat.dAPred.value.val )	
	
		
------------ Recursion over Assertions -----------		


def: checkCondition(trace:OrderedSet(trace::TraceElement), t:trace::TraceElement, daCondition:sBTemPsy::AbstractCondition): Boolean =
		if daCondition.oclIsTypeOf(sBTemPsy::OrCondition) then  
			let orAssertion:sBTemPsy::OrCondition = daCondition.oclAsType(sBTemPsy::OrCondition), 
				orDaCondOne:sBTemPsy::AbstractCondition = orAssertion.condition1,
				orDaCondTwo:sBTemPsy::AbstractCondition = orAssertion.condition2
			in
				--checking on sub-conditions
				(	checkCondition(trace, t, orDaCondOne) or
					checkCondition(trace, t, orDaCondTwo)
				)
		else
			if daCondition.oclIsTypeOf(sBTemPsy::AndCondition) then  
				let andAssertion:sBTemPsy::AndCondition=daCondition.oclAsType(sBTemPsy::AndCondition), 
					andDaCondOne:sBTemPsy::AbstractCondition= andAssertion.condition1,
					andDaCondTwo:sBTemPsy::AbstractCondition= andAssertion.condition2
				in
					--checking on sub-conditions
				(	checkCondition(trace, t, andDaCondOne) and
					checkCondition(trace, t, andDaCondTwo)
				)	
			else 
				let assertion:sBTemPsy::Assertion=daCondition.oclAsType(sBTemPsy::Assertion) in
				checkPredicate(trace, t, assertion)
			endif
		endif	
					
-- auxiliary functions for event-based conditions  
def: keepTrackOfEventVRecord(trace:OrderedSet(trace::TraceElement), tl:Real,tu:Real,assertion:sBTemPsy::Assertion):trace::TraceElement=
	let result:Tuple(index:Integer, violatedPred:Integer, timestampOfViolation:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,violatedPred:Integer,timestampOfViolation:trace::TraceElement) = Tuple{index:Integer=0 , violatedPred:Integer=0,timestampOfViolation:trace::TraceElement=tl} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in
	if iter.violatedPred=1 then  -- if the predicate has been already violated, then stop inner conditions and go till end of trace to report that first seen violation
		iter 
	else	
		if reportPredicate(trace, elem, assertion)=true and elem.generationTime >= tl then 
			Tuple{index:Integer = currentIndex, violatedPred:Integer=1,timestampOfViolation:trace::TraceElement=elem} 
		else 
			Tuple{index:Integer = currentIndex, violatedPred:Integer=iter.violatedPred,timestampOfViolation:trace::TraceElement=iter.timestampOfViolation} 
		endif
	endif	
	) in result.timestampOfViolation	

-------------------------------------------------
-- auxiliary functions for state-based conditions
-------------------------------------------------

--keep track of the last record that satisfies the property predicate before its violation and the very next one that shows the predicate violation
def: reportDualStateAssertion(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::StateAssertion,tl:Real, tu:Real):Sequence(trace::TraceElement)=
	-- target: takes 1 if signal reaches the target value, 0 otherwise
	let result:Tuple(index:Integer, target:Integer, traceElements:Sequence(trace::TraceElement)) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElements:Sequence(trace::TraceElement)) = Tuple{index:Integer=0 , target:Integer=0, traceElements:Sequence(trace::TraceElement)=Sequence{trace->first(),trace->first()}} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  then 
      if iter.target=0 and reportStateSatisfiedPredicate(elem,pattern)=true  then
      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}}
      else
	      	if iter.target=0 and reportStateViolatedPredicate(elem,pattern)=true then
  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1, traceElements:Sequence(trace::TraceElement)=Sequence{iter.traceElements->last(),elem}} 
	      	else
	      		iter
	      	endif
	  endif    
	else
			iter
	endif	      	 		     
) in result.traceElements


--keep track of the record with the minimum and the maximum values for dp_becomes 1 and dp_becomes2 diagnostic patterns of state assertion
def: getMinStateRecordV(trace:OrderedSet(trace::TraceElement),stateAssertion:sBTemPsy::StateAssertion,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, min:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,min:trace::TraceElement) = Tuple{index:Integer=0 ,min:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime<=tu and getValue(elem,stateAssertion.signal).val < getValue(iter.min,stateAssertion.signal).val then 
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=iter.min}
	    endif
	) in result.min

def: getMaxStateRecordV(trace:OrderedSet(trace::TraceElement),stateAssertion:sBTemPsy::StateAssertion,tl:Real,tu:Real):trace::TraceElement=
		let result:Tuple(index:Integer, max:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
		  iter:Tuple(index:Integer,max:trace::TraceElement) = Tuple{index:Integer=0 ,max:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
		  | 
		 let currentIndex:Integer = iter.index + 1 in
		 if  elem.generationTime >= tl and elem.generationTime <=tu and getValue(elem,stateAssertion.signal).val > getValue(iter.max,stateAssertion.signal).val then 
		      Tuple{index:Integer = currentIndex, max:trace::TraceElement=elem}
		    else
		      Tuple{index:Integer = currentIndex, max:trace::TraceElement=iter.max}
		    endif
		) in result.max

def: getViolationInformationForEventAssertion(trace:OrderedSet(trace::TraceElement),  tl:Real,tu:Real,assertion:sBTemPsy::Assertion):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=		 				
	if -- dp_assert1
		trace->exists(t:trace::TraceElement | t.generationTime >= tl and t.generationTime <= tu and reportPredicate(trace, t, assertion) )															     												 				 
    then 	-- diagnostics information
		Set{Tuple{vSignal:String=assertion.signal.id,
		  Records=Sequence{Tuple{
	  		timestamp:Real=keepTrackOfEventVRecord(trace,tl,tu,assertion).generationTime,
	  		signalValue:Real=getValue(keepTrackOfEventVRecord(trace,tl,tu,assertion),assertion.signal).val
		  }},
		  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
		  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_assert_1
		   }}							 
	 else 
	 		 Set{Tuple{vSignal:String=assertion.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}} 						 		  				
	endif
			
def: retrieveTargetAssertion(trace:OrderedSet(trace::TraceElement),daCondition:sBTemPsy::AbstractCondition, tl:Real,tu:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if daCondition.oclIsTypeOf(sBTemPsy::AndCondition) then  
		let andAssertion:sBTemPsy::AndCondition=daCondition.oclAsType(sBTemPsy::AndCondition), 
			andDaCondOne:sBTemPsy::AbstractCondition= andAssertion.condition1,
			andDaCondTwo:sBTemPsy::AbstractCondition= andAssertion.condition2
		in
			if trace->exists(t:trace::TraceElement | 
			   t.generationTime >=tl and t.generationTime <=tu and 	
			   checkCondition(trace, t, andDaCondOne)=false and checkCondition(trace, t, andDaCondTwo))
			then 					
				retrieveTargetAssertion(trace,andDaCondOne,tl,tu)  
			else 		
				if trace->exists(t:trace::TraceElement | 
					t.generationTime >=tl and t.generationTime <=tu and 	
					checkCondition(trace, t, andDaCondOne) and checkCondition(trace, t, andDaCondTwo)=false)
				then 					
					retrieveTargetAssertion(trace,andDaCondTwo,tl,tu)  
				else -- case of 2 violated predicates; --diagnostics information 	
					retrieveTargetAssertion(trace,andDaCondOne,tl,tu)->union(retrieveTargetAssertion(trace,andDaCondTwo,tl,tu) ) 			
				endif
			endif		
	else
		if daCondition.oclIsTypeOf(sBTemPsy::OrCondition) then  
			let orAssertion:sBTemPsy::OrCondition = daCondition.oclAsType(sBTemPsy::OrCondition), 
				orDaCondOne:sBTemPsy::AbstractCondition = orAssertion.condition1,
				orDaCondTwo:sBTemPsy::AbstractCondition = orAssertion.condition2
			in
			-- diagnostic pattern
			if trace->exists(t:trace::TraceElement | 
				t.generationTime >=tl and t.generationTime <=tu and 	
				checkCondition(trace, t, orDaCondOne)=false and checkCondition(trace, t, orDaCondTwo)=false)
			then 			
				retrieveTargetAssertion(trace,orDaCondOne,tl,tu)->union(retrieveTargetAssertion(trace,orDaCondTwo,tl,tu) )  
			else 	
				Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}} 									
			endif
		else 
			-- simple assertion case
			let assertion:sBTemPsy::Assertion=daCondition.oclAsType(sBTemPsy::Assertion) in
				getViolationInformationForEventAssertion(trace,tl,tu,assertion)				
		endif
	endif
	
---------------------------------------------------------------
-- auxiliary functions for Rise Time behavior: i_dp_rises4: dual state
----
def: reportDualRiseTime(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Rise,tl:Real, tu:Real):Sequence(trace::TraceElement)=
	-- target: takes 1 if signal reaches the target value, 0 otherwise
	let result:Tuple(index:Integer, target:Integer, traceElements:Sequence(trace::TraceElement)) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElements:Sequence(trace::TraceElement)) = Tuple{index:Integer=0 , target:Integer=0, traceElements:Sequence(trace::TraceElement)=Sequence{trace->first(),trace->first()}} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  then 
	      if iter.target=0 and getValue(elem,pattern.signal).val >= pattern.targetValue.val  then
	      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}}
	      else
		      	if iter.target=0 and getValue(elem,pattern.signal).val < pattern.targetValue.val then
	  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1, traceElements:Sequence(trace::TraceElement)=Sequence{iter.traceElements->last(),elem}} 
		      	else
		      		iter
		      endif
		  endif    
	else
			iter
	endif	      	 		     
) in result.traceElements
--------------------------------------------------------------------------------------
-- auxiliary functions for Rise Time behavior: dp_rises_3: no sat of monotonicity constraint
--------------------------------------------------------------------------------------
 
def: reportMonotonicityViolationRiseTime(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Rise,tl:Real, tu:Real):Sequence(trace::TraceElement)=
	-- found: monotonicity condition satisfied
	-- stop: signal reaches target value
	let result:Tuple(index:Integer, stop:Integer, found:Integer, traceElements:Sequence(trace::TraceElement)) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,stop:Integer, found:Integer, traceElements:Sequence(trace::TraceElement)) = Tuple{index:Integer=0 , stop:Integer=0, found:Integer=0, traceElements:Sequence(trace::TraceElement)=Sequence{trace->first(),trace->first()}} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu and iter.stop=0 and iter.found=0 and  getValue(elem,pattern.signal).val < pattern.targetValue.val  then 
	      if getValue(elem,pattern.signal).val < getValue(iter.traceElements->last(),pattern.signal).val  then
	      	 Tuple{index:Integer = currentIndex, stop:Integer=iter.stop, found:Integer=1, traceElements:Sequence(trace::TraceElement)=Sequence{iter.traceElements->last(),elem}}
	      else
  	 		 Tuple{index:Integer = currentIndex, stop:Integer=iter.stop, found:Integer=iter.found, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}} 
	      endif
	else
			Tuple{index:Integer = currentIndex, stop:Integer=1, found:Integer=iter.found, traceElements:Sequence(trace::TraceElement)=iter.traceElements} 
	endif	      	 		     
) in result.traceElements

----------------------------------------------------------------
-- auxiliary functions for Fall Time behavior: dp_rises4: dual state
----------------------------------------------------------------
def: reportDualFallTime(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Fall,tl:Real, tu:Real):Sequence(trace::TraceElement)=
	-- target: takes 1 if signal reaches the target value, 0 otherwise
	let result:Tuple(index:Integer, target:Integer, traceElements:Sequence(trace::TraceElement)) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElements:Sequence(trace::TraceElement)) = Tuple{index:Integer=0 , target:Integer=0, traceElements:Sequence(trace::TraceElement)=Sequence{trace->first(),trace->first()}} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  then 
	      if iter.target=0 and getValue(elem,pattern.signal).val < pattern.targetValue.val  then
	      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}}
	      else
		      	if iter.target=0 and getValue(elem,pattern.signal).val >= pattern.targetValue.val then
	  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1, traceElements:Sequence(trace::TraceElement)=Sequence{iter.traceElements->last(),elem}} 
		      	else
		      		iter
		      endif
		  endif    
	else
			iter
	endif	      	 		     
	) in result.traceElements
--------------------------------------------------------------------------------------
-- auxiliary functions for Fall Time behavior: dp_falls3: no sat of monotonicity constraint
--------------------------------------------------------------------------------------

def: reportMonotonicityViolationFallTime(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Fall,tl:Real, tu:Real):Sequence(trace::TraceElement)=
	let result:Tuple(index:Integer, stop:Integer, found:Integer, traceElements:Sequence(trace::TraceElement)) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,stop:Integer, found:Integer, traceElements:Sequence(trace::TraceElement)) = Tuple{index:Integer=0 , stop:Integer=0, found:Integer=0, traceElements:Sequence(trace::TraceElement)=Sequence{trace->first(),trace->first()}} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu and iter.stop=0 and iter.found=0 and  getValue(elem,pattern.signal).val > pattern.targetValue.val  then 
	      if getValue(elem,pattern.signal).val > getValue(iter.traceElements->last(),pattern.signal).val  then
	      	 Tuple{index:Integer = currentIndex, stop:Integer=iter.stop, found:Integer=1, traceElements:Sequence(trace::TraceElement)=Sequence{iter.traceElements->last(),elem}}
	      else
  	 		 Tuple{index:Integer = currentIndex, stop:Integer=iter.stop, found:Integer=iter.found, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}} 
	      endif
	else
			Tuple{index:Integer = currentIndex, stop:Integer=1, found:Integer=iter.found, traceElements:Sequence(trace::TraceElement)=iter.traceElements} 
	endif	      	 		     
) in result.traceElements

--------------------------------------------
-- auxiliary functions for overshoot pattern
--------------------------------------------

-- auxiliary functions for Overshoot behavior: i_dp_overshoots4: dual state
def: reportDualOvershoot(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Overshoot,tl:Real, tu:Real):Sequence(trace::TraceElement)=
	-- target: takes 1 if signal reaches the target value, 0 otherwise
	let result:Tuple(index:Integer, target:Integer, traceElements:Sequence(trace::TraceElement)) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElements:Sequence(trace::TraceElement)) = Tuple{index:Integer=0 , target:Integer=0, traceElements:Sequence(trace::TraceElement)=Sequence{trace->first(),trace->first()}} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  then 
	      if iter.target=0 and getValue(elem,pattern.signal).val >= pattern.targetValue.val  then
	      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}}
	      else
		      	if iter.target=0 and getValue(elem,pattern.signal).val < pattern.targetValue.val then
	  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1, traceElements:Sequence(trace::TraceElement)=Sequence{iter.traceElements->last(),elem}} 
		      	else
		      		iter
		      endif
		  endif    
	else
			iter
	endif	      	 		     
) in result.traceElements


-- auxiliary functions for overshoot behavior: dp_overshoots3: no sat of monotonicity constraint
def: reportMonotonicityViolationOvershoot(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Overshoot,tl:Real, tu:Real):Sequence(trace::TraceElement)=
	-- found: monotonicity condition satisfied
	-- stop: signal reaches target value
	let result:Tuple(index:Integer, stop:Integer, found:Integer, traceElements:Sequence(trace::TraceElement)) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,stop:Integer, found:Integer, traceElements:Sequence(trace::TraceElement)) = Tuple{index:Integer=0 , stop:Integer=0, found:Integer=0, traceElements:Sequence(trace::TraceElement)=Sequence{trace->first(),trace->first()}} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu and iter.stop=0 and iter.found=0 and getValue(elem,pattern.signal).val <= pattern.targetValue.val+pattern.maximumValue.val.abs() then 
	      if getValue(elem,pattern.signal).val < getValue(iter.traceElements->last(),pattern.signal).val and  getValue(iter.traceElements->last(),pattern.signal).val <= pattern.targetValue.val   then
	      	 Tuple{index:Integer = currentIndex, stop:Integer=iter.stop, found:Integer=1, traceElements:Sequence(trace::TraceElement)=Sequence{iter.traceElements->last(),elem}}
	      else
  	 		 Tuple{index:Integer = currentIndex, stop:Integer=iter.stop, found:Integer=iter.found, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}} 
	      endif
	else	-- if signal exceeds the maximum value
			if getValue(elem,pattern.signal).val > pattern.targetValue.val+pattern.maximumValue.val then 
				Tuple{index:Integer = currentIndex, stop:Integer=0, found:Integer=0, traceElements:Sequence(trace::TraceElement)=iter.traceElements} 
			else -- target value is met
				Tuple{index:Integer = currentIndex, stop:Integer=1, found:Integer=iter.found, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}} 
			endif		
	endif	      	 		     
) in result.traceElements


-------------------------------------
-- auxiliary functions for undershoot
-------------------------------------

-- auxiliary functions for Undershoot behavior: i_dp_undershoots4: dual state
def: reportDualUndershoot(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Undershoot,tl:Real, tu:Real):Sequence(trace::TraceElement)=
	-- target: takes 1 if signal reaches the target value, 0 otherwise
	let result:Tuple(index:Integer, target:Integer, traceElements:Sequence(trace::TraceElement)) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElements:Sequence(trace::TraceElement)) = Tuple{index:Integer=0 , target:Integer=0, traceElements:Sequence(trace::TraceElement)=Sequence{trace->first(),trace->first()}} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  then 
	      if iter.target=0 and getValue(elem,pattern.signal).val < pattern.targetValue.val  then
	      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}}
	      else
		      	if iter.target=0 and getValue(elem,pattern.signal).val >= pattern.targetValue.val then
	  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1, traceElements:Sequence(trace::TraceElement)=Sequence{iter.traceElements->last(),elem}} 
		      	else
		      		iter
		      endif
		  endif    
	else
			iter
	endif	      	 		     
) in result.traceElements

-- auxiliary functions for Undershoot behavior: i_dp_undershoots4: no sat of monotonicity constraint
def: reportMonotonicityViolationUndershoot(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Undershoot,tl:Real, tu:Real):Sequence(trace::TraceElement)=
	-- found: monotonicity condition satisfied
	-- stop: signal reaches target value
	let result:Tuple(index:Integer, stop:Integer, found:Integer, traceElements:Sequence(trace::TraceElement)) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,stop:Integer, found:Integer, traceElements:Sequence(trace::TraceElement)) = Tuple{index:Integer=0 , stop:Integer=0, found:Integer=0, traceElements:Sequence(trace::TraceElement)=Sequence{trace->first(),trace->first()}} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu and iter.stop=0 and iter.found=0 and getValue(elem,pattern.signal).val >= pattern.targetValue.val-pattern.maximumValue.val.abs() then 
	      if getValue(elem,pattern.signal).val > getValue(iter.traceElements->last(),pattern.signal).val and  getValue(iter.traceElements->last(),pattern.signal).val >= pattern.targetValue.val   then
	      	 Tuple{index:Integer = currentIndex, stop:Integer=iter.stop, found:Integer=1, traceElements:Sequence(trace::TraceElement)=Sequence{iter.traceElements->last(),elem}}
	      else
  	 		 Tuple{index:Integer = currentIndex, stop:Integer=iter.stop, found:Integer=iter.found, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}} 
	      endif
	else	-- if signal exceeds the maximum value
			if getValue(elem,pattern.signal).val < pattern.targetValue.val-pattern.maximumValue.val.abs() then 
				Tuple{index:Integer = currentIndex, stop:Integer=0, found:Integer=0, traceElements:Sequence(trace::TraceElement)=iter.traceElements} 
			else -- target value is met
				Tuple{index:Integer = currentIndex, stop:Integer=1, found:Integer=iter.found, traceElements:Sequence(trace::TraceElement)=Sequence{elem,elem}} 
			endif		
	endif	      	 		     
) in result.traceElements

----------------------------------------
-- Auxiliary functions for spike pattern
----------------------------------------
---------  Is minimum  ---------
def: isMinimum(subtrace:OrderedSet(trace::TraceElement), min:trace::TraceElement, firstTimeInInterval:Real, lastTimeInInterval:Real, signal:sBTemPsy::Signal):Boolean = 
		subtrace -> exists(elem | elem.generationTime=min.generationTime and getValue(elem, signal).val=getValue(min,signal).val)
	and
		(subtrace->
		select(elem | 
		elem.generationTime >= firstTimeInInterval and elem.generationTime <= lastTimeInInterval).signalValue 
		-> select( elem | elem.key.id=signal.id).value.val
		->min()=getValue(min,signal).val
		) 
	and 
		(subtrace ->forAll(elem1, elem2 | 
		(firstTimeInInterval<= elem1.generationTime and elem1.generationTime <= elem2.generationTime 
			and elem2.generationTime <=  min.generationTime and min.generationTime<=lastTimeInInterval 
		) 
		implies 
		getValue(elem1,signal).val >= getValue(elem2,signal).val
			)
		) 
	and 
		(subtrace -> forAll(elem1, elem2 |  
				(firstTimeInInterval<=min.generationTime and min.generationTime <= elem1.generationTime  
					and elem1.generationTime <= elem2.generationTime and elem2.generationTime <= lastTimeInInterval 
				) 
				implies 
				getValue(elem1,signal).val <= getValue(elem2,signal).val
			)	
		) 	

-----------  Is maximum  ---------
def: isLocalMaximum(subtrace:OrderedSet(trace::TraceElement), max:trace::TraceElement, firstTimeInInterval:Real, lastTimeInInterval:Real, signal:sBTemPsy::Signal):Boolean = 
		subtrace -> exists(elem | elem.generationTime=max.generationTime and getValue(elem,signal).val=getValue(max,signal).val)
	and
		(subtrace->
		select(elem | 
		elem.generationTime >= firstTimeInInterval and elem.generationTime <= lastTimeInInterval).signalValue
		-> select(elem |elem.key.id=signal.id).value.val				
		->max()=getValue(max,signal).val
		) 
	and
		(subtrace ->  
		forAll(elem1, elem2 | 
			(firstTimeInInterval<= elem1.generationTime and elem1.generationTime < elem2.generationTime 
			and elem2.generationTime <=  max.generationTime and max.generationTime<=lastTimeInInterval) 
			implies 
			getValue(elem1,signal).val < getValue(elem2,signal).val 
		)
		) 
	and 
		(subtrace ->  
		forAll(elem1, elem2 | 
			(firstTimeInInterval<=max.generationTime and max.generationTime <= elem1.generationTime  
				and elem1.generationTime < elem2.generationTime and elem2.generationTime <= lastTimeInInterval) 
			implies 
			getValue(elem1,signal).val > getValue(elem2,signal).val 
		)
		) 	
	
---------  Is strict minimum  ---------
def: isLocalMinimum(subtrace:OrderedSet(trace::TraceElement), min:trace::TraceElement, firstTimeInInterval:Real, lastTimeInInterval:Real, signal:sBTemPsy::Signal):Boolean = 
		subtrace -> exists(elem | elem.generationTime=min.generationTime and getValue(elem,signal)=getValue(min,signal))
	and
		subtrace->select(elem | 
		elem.generationTime >= firstTimeInInterval and elem.generationTime <= lastTimeInInterval 
		).signalValue
		-> select(elem |elem.key.id=signal.id).value.val
		->min()=getValue(min,signal).val
	and 
		(subtrace ->
		forAll(elem1, elem2 | 
			(firstTimeInInterval<= elem1.generationTime and elem1.generationTime < elem2.generationTime and elem2.generationTime <= min.generationTime and min.generationTime<=lastTimeInInterval ) 
			implies 
			getValue(elem1, signal).val > getValue(elem2, signal).val 
		)
		) 
	and 
		(subtrace ->  
		forAll(elem1, elem2 |  
		(firstTimeInInterval<=min.generationTime and min.generationTime <= elem1.generationTime and elem1.generationTime < elem2.generationTime and elem2.generationTime <= lastTimeInInterval) 
		implies 
		getValue(elem1, signal).val < getValue(elem2, signal).val
		)	
		) 		

---------  Is strict maximum  ---------
def: isMaximum(subtrace:OrderedSet(trace::TraceElement), max:trace::TraceElement, firstTimeInInterval:Real, lastTimeInInterval:Real, signal:sBTemPsy::Signal):Boolean = 
	subtrace -> exists(elem | elem.generationTime=max.generationTime and getValue(elem,signal)=getValue(max,signal))
	and
	(subtrace->
	select(elem | 
	elem.generationTime >= firstTimeInInterval and elem.generationTime <= lastTimeInInterval).signalValue
	-> select(elem |elem.key.id=signal.id).value.val
	->max()=getValue(max,signal).val) 
	and
	(subtrace ->  forAll(elem1, elem2 | 
	(firstTimeInInterval<= elem1.generationTime and elem1.generationTime <= elem2.generationTime 
			and elem2.generationTime <=  max.generationTime and max.generationTime<=lastTimeInInterval) 
	implies 
		getValue(elem1,signal).val <= getValue(elem2,signal).val
	)
	) 
	and 
	(subtrace ->  forAll(elem1, elem2 | 
			(firstTimeInInterval<=max.generationTime and max.generationTime <= elem1.generationTime  and 
			elem1.generationTime <= elem2.generationTime and elem2.generationTime <= lastTimeInInterval) 
		implies 
			getValue(elem1,signal).val >= getValue(elem2,signal).val 
		)
	) 				
		
----------------------------
-- Spike diagnostic patterns
----------------------------

def: noSpikeFlatSignal(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Spike,tl:Real,tu:Real):Boolean=
	subtrace->forAll(t| 
		(t.generationTime >=tl and t.generationTime <=tu) implies
 		getValue(t,pattern.signal).val= getValue(subtrace->first(),pattern.signal).val
	)


def: noSpikeSignalDecreases(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Spike,tl:Real,tu:Real):Boolean=
	subtrace->forAll(t1 | 
		t1.generationTime >= tl and t1.generationTime <tu implies 
			(subtrace->forAll (t2| 
				t2.generationTime > t1.generationTime and t2.generationTime <= tu implies
				(getValue(t1,pattern.signal).val >= getValue(t2,pattern.signal).val)
				)
			)		
		) 					
															
def: noSpikeSignalIncreases(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Spike,tl:Real,tu:Real):Boolean=
subtrace->forAll(t1 | 
	t1.generationTime >= tl and t1.generationTime <tu implies 
		(subtrace->forAll (t2| 
		t2.generationTime > t1.generationTime and t2.generationTime <= tu implies
		(getValue(t1,pattern.signal).val <= getValue(t2,pattern.signal).val)
		)
		)	
	) 													
	
def: spikeAmpIsSat(amplitude:Real,spkPattern:sBTemPsy::Spike):Boolean=
	let 
	spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature)=spkPattern.spkFeat, -- --, --{'a','w'} e.g.,{'a'->name,pred,'w'->name,pred} ; {a: name,pred}
	indAmp:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::a)
	in 
		( spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::EQL and amplitude = spikeFeaturesList->at(indAmp).sFPred.value.val ) 
		or 
		( spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::GRT and amplitude > spikeFeaturesList->at(indAmp).sFPred.value.val) 
		or 
		( spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::LESS and amplitude < spikeFeaturesList->at(indAmp).sFPred.value.val) 
		or 
		( spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::GRTEQ and amplitude >= spikeFeaturesList->at(indAmp).sFPred.value.val) 
		or 
		(spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::LESSEQ and amplitude <= spikeFeaturesList->at(indAmp).sFPred.value.val) 
		or 
		(spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::DIFF and amplitude <> spikeFeaturesList->at(indAmp).sFPred.value.val)
	

def: oscAmpIsSat(amplitude:Real,spkPattern:sBTemPsy::Oscillation):Boolean=
	let 
	oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature)=spkPattern.oscFeat, -- --, --{'a','w'} e.g.,{'a'->name,pred,'w'->name,pred} ; {a: name,pred}
	indAmp:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::a)
	in 
		( oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::EQL and amplitude = oscFeaturesList->at(indAmp).oscFPred.value.val ) 
		or 
		( oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::GRT and amplitude > oscFeaturesList->at(indAmp).oscFPred.value.val) 
		or 
		( oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::LESS and amplitude < oscFeaturesList->at(indAmp).oscFPred.value.val) 
		or 
		( oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::GRTEQ and amplitude >= oscFeaturesList->at(indAmp).oscFPred.value.val) 
		or 
		(oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::LESSEQ and amplitude <= oscFeaturesList->at(indAmp).oscFPred.value.val) 
		or 
		(oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::DIFF and amplitude <> oscFeaturesList->at(indAmp).oscFPred.value.val)
	

def: oscPeriodIsSat(period:Real,spkPattern:sBTemPsy::Oscillation):Boolean=
	let 
	oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature)=spkPattern.oscFeat, -- --, --{'a','w'} e.g.,{'a'->name,pred,'w'->name,pred} ; {a: name,pred}
	indP:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::w)
	in 
		( oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::EQL and period = oscFeaturesList->at(indP).oscFPred.value.val ) 
		or 
		( oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::GRT and period > oscFeaturesList->at(indP).oscFPred.value.val) 
		or 
		( oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::LESS and period < oscFeaturesList->at(indP).oscFPred.value.val) 
		or 
		( oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::GRTEQ and period >= oscFeaturesList->at(indP).oscFPred.value.val) 
		or 
		(oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::LESSEQ and period <= oscFeaturesList->at(indP).oscFPred.value.val) 
		or 
		(oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::DIFF and period <> oscFeaturesList->at(indP).oscFPred.value.val)
	




	
def: spikeWidthIsSat(width:Real,spkPattern:sBTemPsy::Spike):Boolean=
	let 
	spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature)=spkPattern.spkFeat, -- --, --{'a','w'} e.g.,{'a'->name,pred,'w'->name,pred} ; {a: name,pred}
	indWidth:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::w)
	in 
		( spikeFeaturesList->at(indWidth).sFPred.rOp = sBTemPsy::RelationalOperator::EQL and width = spikeFeaturesList->at(indWidth).sFPred.value.val ) 
		or 
		( spikeFeaturesList->at(indWidth).sFPred.rOp = sBTemPsy::RelationalOperator::GRT and width > spikeFeaturesList->at(indWidth).sFPred.value.val) 
		or 
		( spikeFeaturesList->at(indWidth).sFPred.rOp = sBTemPsy::RelationalOperator::LESS and width < spikeFeaturesList->at(indWidth).sFPred.value.val) 
		or 
		( spikeFeaturesList->at(indWidth).sFPred.rOp = sBTemPsy::RelationalOperator::GRTEQ and width >= spikeFeaturesList->at(indWidth).sFPred.value.val) 
		or 
		(spikeFeaturesList->at(indWidth).sFPred.rOp = sBTemPsy::RelationalOperator::LESSEQ and width <= spikeFeaturesList->at(indWidth).sFPred.value.val) 
		or 
		(spikeFeaturesList->at(indWidth).sFPred.rOp = sBTemPsy::RelationalOperator::DIFF and width <> spikeFeaturesList->at(indWidth).sFPred.value.val)
			
---------------------------------------------------------------------------------------
-- diagnostic pattern and diagnostic information for amplitude-based predicate of spike
---------------------------------------------------------------------------------------		
def: getSpikeAmpDiagInfos(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Spike,tl:Real,tu:Real,spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature),indAmp:Integer):Sequence(Real)=
	let 
		ampThreshold:Real=spikeFeaturesList->at(indAmp).sFPred.value.val,
		result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfAmpl:Real,secondHalfAmpl:Real,spikeAmp:Real,firstExtTimeStamp:Real,closestp2pToSat:Real,spikeAmpInfos:Sequence(Real)) = 
		subtrace->iterate(elem:trace::TraceElement; 
		  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfAmpl:Real,secondHalfAmpl:Real,spikeAmp:Real,firstExtTimeStamp:Real,closestp2pToSat:Real,spikeAmpInfos:Sequence(Real)) = 
		  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,firstHalfAmpl:Real=0,secondHalfAmpl:Real=0,spikeAmp:Real=0,firstExtTimeStamp:Real=0,closestp2pToSat:Real=1000000000,spikeAmpInfos:Sequence(Real)=Sequence{0,0,0}} -- it starts from the first index of the trace
		  	|  --spikeAmpInfos is a sequence that returns 3 reals: the timestmap of the first extremum of the closest spike to satisfying the amplitude predicate, the timestamp of the last extremum of that spike and its amplitude:
		 let currentIndex:Integer = iter.index + 1,
		 	 lastSeenRec:trace::TraceElement=elem
		 in
	 	-- iterate over all trace elements to return diagnostic information i-dp-spike-1:
	 		if iter.derivative=0 then
	 			-- if positive derivative:
	 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
	 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}} 
	 			-- if derivative is negative: 
 				else 
 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}} 
	 				else 
	 					-- case of flat signal:
	 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}					
	 				endif
	 			endif
	 		else 
	 			-- first extremum detected, missing strict local extremum
	 			if iter.derivative=1 then
		 			--1 case of strict maximum:  
					if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 		Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,spikeAmp:Real=iter.firstHalfAmpl.max(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}				
	 				else -- signal still increasing:
	 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl+getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=iter.firstHalfAmpl+(getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}				
	 					else 
	 					-- 2- case of strict minimum:
	 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 				Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,spikeAmp:Real=iter.firstHalfAmpl.max(getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}				
	 						else 	-- signal still decreasing:
	 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=iter.firstHalfAmpl+getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=iter.firstHalfAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}				
	 							else 	
	 								-- case of flat signal:
	 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=0,secondHalfAmpl:Real=0,spikeAmp:Real=0,firstExtTimeStamp:Real=0,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}	
	 							endif
	 						endif	
	 					endif
	 				endif
		 		else  -- case of derivative=2
	 			-- first extremum and first missing strict local extremum detected, missing last extremum:
					--1 case of local maximum: 
					if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
						-- if the last seen spike is the closest to satisfying the amplitude-based predicate:
						if (iter.spikeAmp-ampThreshold).abs() < (iter.closestp2pToSat-ampThreshold).abs() then
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.spikeAmp,spikeAmpInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeAmp}}
						else 
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}
						endif
					else 
						--2 case of local minimum: 
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 							-- if the last seen spike is the closest to satisfying the amplitude-based predicate:
 							if (iter.spikeAmp-ampThreshold).abs() < (iter.closestp2pToSat-ampThreshold).abs() then
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.spikeAmp,spikeAmpInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeAmp}}
 							else 
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}
 							endif
						else 
							--3 case of flat signal:
 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
								--if the last seen spike is the closest to satisfying the amplitude-based predicate:
								if (iter.spikeAmp-ampThreshold).abs() < (iter.closestp2pToSat-ampThreshold).abs() then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,firstExtTimeStamp:Real=0,closestp2pToSat:Real=iter.spikeAmp,spikeAmpInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeAmp}}
 								else 
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,firstExtTimeStamp:Real=0,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}
 								endif
 							else 
 								-- signal still increasing or decreasing			
	 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),spikeAmp:Real=iter.firstHalfAmpl.max(iter.secondHalfAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs()),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}	
	 						endif
		 				endif
	 				endif
	 			endif
	 		endif
	 	 	
) in result.spikeAmpInfos -- diagnostic information for the closest spike to the satisfaction of the spike-based predicate
	
	
def: allSpikesViolateAmplitude(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Spike,tl:Real,tu:Real,spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature),indAmp:Integer):Boolean=
	let result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfAmpl:Real,secondHalfAmpl:Real,spikeAmp:Real,satDP:Integer) = 
		subtrace->iterate(elem:trace::TraceElement; 
		  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfAmpl:Real,secondHalfAmpl:Real,spikeAmp:Real,satDP:Integer) = 
		  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,firstHalfAmpl:Real=0,secondHalfAmpl:Real=0,spikeAmp:Real=0,satDP:Integer=1} -- it starts from the first index of the trace
		  	| 
		 let currentIndex:Integer = iter.index + 1,
		 	 lastSeenRec:trace::TraceElement=elem 
		 in
		 	if iter.satDP=0 then  -- stop checking all conditions once there exists at least one spike that does not violate the amplitude-based predicate
		 		Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=0,secondHalfAmpl:Real=0,spikeAmp:Real=0,satDP:Integer=0} 
		 	else 
		 		-- iterate over all trace elements to check dp-spike-1
		 		if iter.derivative=0 then
		 			-- if positive derivative:
		 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
		 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,satDP:Integer=iter.satDP} 
		 			-- if derivative is negative: 
	 				else 
	 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
	 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,satDP:Integer=iter.satDP} 
		 				else 
		 					-- case of flat signal:
		 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,satDP:Integer=iter.satDP}					
		 				endif
		 			endif
		 		else 
		 			-- first extremum detected, missing strict local extremum
		 			if iter.derivative=1 then
			 			--1 case of strict maximum:  
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
					 		Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,spikeAmp:Real=iter.firstHalfAmpl.max(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val),satDP:Integer=iter.satDP}				
		 				else -- signal still increasing:
		 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
					 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl+getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=iter.firstHalfAmpl+(getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val),satDP:Integer=iter.satDP}				
		 					else 
		 					-- 2- case of strict minimum:
		 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
					 				Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,spikeAmp:Real=iter.firstHalfAmpl.max(getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val),satDP:Integer=iter.satDP}				
		 						else 	-- signal still decreasing:
		 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
					 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=iter.firstHalfAmpl+getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=iter.firstHalfAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val),satDP:Integer=iter.satDP}				
		 							else 	
		 								-- case of flat signal:
		 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=0,secondHalfAmpl:Real=0,spikeAmp:Real=0,satDP:Integer=iter.satDP}	
		 							endif
		 						endif	
		 					endif
		 				endif
			 		else  -- case of derivative=2
		 			-- first extremum and first missing strict local extremum detected, missing last extremum:
 						--1 case of local maximum: 
 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
 							-- if spike amplitude does not violate the amplitude-based predicate:
 							if spikeAmpIsSat(iter.spikeAmp,pattern)=true then
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,satDP:Integer=0}
 							else 
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,satDP:Integer=iter.satDP}
 							endif
 						else 
 							--2 case of local minimum: 
 							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
	 							-- if spike amplitude does not violate the amplitude-based predicate:
	 							if spikeAmpIsSat(iter.spikeAmp,pattern)=true then
	 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,satDP:Integer=0}
	 							else 
	 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,satDP:Integer=iter.satDP}
	 							endif
 							else 
 								--3 case of flat signal:
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
									if spikeAmpIsSat(iter.spikeAmp,pattern)=true then
	 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,satDP:Integer=0}
	 								else 
	 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,satDP:Integer=iter.satDP}
	 								endif
	 							else 
	 								-- signal still increasing or decreasing			
		 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),spikeAmp:Real=iter.firstHalfAmpl.max(iter.secondHalfAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs()),satDP:Integer=iter.satDP}	
		 						endif
			 				endif
		 				endif
		 			endif
		 		endif
		 	endif 	
) in result.satDP = 0-- there exists at least one spike occurrence that satisfies the amplitude predicate and violates the diagnostic pattern

--------------------------------------------------------------------------------------
-- diagnostic pattern and diagnostic information for width-based predicate of spike
--------------------------------------------------------------------------------------
def: getSpikeWidthDiagInfos(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Spike,tl:Real,tu:Real,spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature),indW:Integer):Sequence(Real)=
	let 
		widthThreshold:Real=spikeFeaturesList->at(indW).sFPred.value.val,
		result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfWidth:Real,secondHalfWidth:Real,spikeWidth:Real,firstExtTimeStamp:Real,closestWidthToSat:Real,spikeWidthInfos:Sequence(Real)) = 
		subtrace->iterate(elem:trace::TraceElement; 
		  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfWidth:Real,secondHalfWidth:Real,spikeWidth:Real,firstExtTimeStamp:Real,closestWidthToSat:Real,spikeWidthInfos:Sequence(Real)) = 
		  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,firstExtTimeStamp:Real=0,closestWidthToSat:Real=-1000000000,spikeWidthInfos:Sequence(Real)=Sequence{0,0,0}} -- it starts from the first index of the trace
		  	|  --spikeWidthInfos is a sequence that returns 3 reals: the timestmap of the first extremum of the closest spike to satisfying the width predicate, the timestamp of the last extremum of that spike and its width:
		 let currentIndex:Integer = iter.index + 1,
		 	 lastSeenRec:trace::TraceElement=elem
		 in
	 	-- iterate over all trace elements to return diagnostic information i-dp-spike-1:
	 		if iter.derivative=0 then
	 			-- if positive derivative:
	 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
	 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}} 
	 			-- if derivative is negative: 
 				else 
 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}} 
	 				else 
	 					-- case of flat signal:
	 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=iter.secondHalfWidth,spikeWidth:Real=iter.spikeWidth,firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}					
	 				endif
	 			endif
	 		else 
	 			-- first extremum detected, missing strict local extremum
	 			if iter.derivative=1 then
		 			--1 case of strict maximum:  
					if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 		Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,spikeWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}				
	 				else -- signal still increasing:
	 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),secondHalfWidth:Real=0,spikeWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}				
	 					else 
	 					-- 2- case of strict minimum:
	 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 				Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,spikeWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}				
	 						else 	-- signal still decreasing:
	 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),secondHalfWidth:Real=0,spikeWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}				
	 							else 	
	 								-- case of flat signal:
	 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,firstExtTimeStamp:Real=0,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}	
	 							endif
	 						endif	
	 					endif
	 				endif
		 		else  -- case of derivative=2
	 			-- first extremum and first missing strict local extremum detected, missing last extremum:
					--1 case of local maximum: 
					if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
						-- if the last seen spike is the closest to satisfying the width-based predicate:
						if (iter.spikeWidth-widthThreshold).abs() < (iter.closestWidthToSat-widthThreshold).abs() then
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestWidthToSat:Real=iter.spikeWidth,spikeWidthInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeWidth}}
						else 
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}
						endif
					else 
						--2 case of local minimum: 
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 							-- if the last seen spike is the closest to satisfying the width-based predicate:
 							if (iter.spikeWidth-widthThreshold).abs() < (iter.closestWidthToSat-widthThreshold).abs() then
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestWidthToSat:Real=iter.spikeWidth,spikeWidthInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeWidth}}
 							else 
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}
 							endif
						else 
							--3 case of flat signal:
 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
								--if the last seen spike is the closest to satisfying the width-based predicate:
								if (iter.spikeWidth-widthThreshold).abs() < (iter.closestWidthToSat-widthThreshold).abs() then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,firstExtTimeStamp:Real=0,closestWidthToSat:Real=iter.spikeWidth,spikeWidthInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeWidth}}
 								else 
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,firstExtTimeStamp:Real=0,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}
 								endif
 							else 
 								-- signal still increasing or decreasing			
	 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=iter.secondHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),spikeWidth:Real=iter.firstHalfWidth+(iter.secondHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime)),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestWidthToSat:Real=iter.closestWidthToSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}	
	 						endif
		 				endif
	 				endif
	 			endif
	 		endif
	 	 	
) in result.spikeWidthInfos -- diagnostic information for the closest spike to the satisfaction of the spike-based predicate


def: allSpikesViolateWidth(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Spike,tl:Real,tu:Real,spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature),indDur:Integer):Boolean=
	let result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfWidth:Real,secondHalfWidth:Real,spikeWidth:Real,satDP:Integer) = 
	subtrace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfWidth:Real,secondHalfWidth:Real,spikeWidth:Real,satDP:Integer) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,satDP:Integer=1} -- it starts from the first index of the trace
	  	| 
	 let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	 in
	 	if iter.satDP=0 then  -- stop checking all conditions once there exists at least one spike that does not violate the amplitude-based predicate
	 		Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,satDP:Integer=0} 
	 	else 
	 		-- iterate over all trace elements to check dp-spike-1
	 		if iter.derivative=0 then
	 			-- if positive derivative:
	 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
	 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,satDP:Integer=iter.satDP} 
	 			-- if derivative is negative: 
 				else 
 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,satDP:Integer=iter.satDP} 
	 				else 
	 					-- case of flat signal:
	 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=iter.secondHalfWidth,spikeWidth:Real=iter.spikeWidth,satDP:Integer=iter.satDP}					
	 				endif
	 			endif
	 		else 
	 			-- first extremum detected, missing strict local extremum
	 			if iter.derivative=1 then
		 			--1 case of strict maximum:  
					if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 		Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,spikeWidth:Real=iter.spikeWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),satDP:Integer=iter.satDP}				
	 				else -- signal still increasing:
	 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),secondHalfWidth:Real=0,spikeWidth:Real=iter.spikeWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),satDP:Integer=iter.satDP}				
	 					else 
	 					-- 2- case of strict minimum:
	 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 				Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,spikeWidth:Real=iter.spikeWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),satDP:Integer=iter.satDP}				
	 						else 	-- signal still decreasing:
	 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),secondHalfWidth:Real=0,spikeWidth:Real=iter.spikeWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),satDP:Integer=iter.satDP}				
	 							else 	
	 								-- case of flat signal:
	 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,satDP:Integer=iter.satDP}	
	 							endif
	 						endif	
	 					endif
	 				endif
		 		else  -- case of derivative=2
	 			-- first extremum and first missing strict local extremum detected, missing last extremum:
					--1 case of local maximum: 
					if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
						-- if spike amplitude does not violate the width-based predicate:
						if spikeWidthIsSat(iter.spikeWidth,pattern)=true then
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,satDP:Integer=0}
						else 
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,satDP:Integer=iter.satDP}
						endif
					else 
						--2 case of local minimum: 
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 							-- if spike amplitude does not violate the width-based predicate:
 							if spikeWidthIsSat(iter.spikeWidth,pattern)=true then
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,satDP:Integer=0}
 							else 
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,satDP:Integer=iter.satDP}
 							endif
						else 
							--3 case of flat signal:
 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
								if spikeWidthIsSat(iter.spikeWidth,pattern)=true then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=iter.secondHalfWidth,spikeWidth:Real=iter.spikeWidth,satDP:Integer=0}
 								else 
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=iter.secondHalfWidth,spikeWidth:Real=iter.spikeWidth,satDP:Integer=iter.satDP}
 								endif
 							else 
 								-- signal still increasing or decreasing			
	 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=iter.secondHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),spikeWidth:Real=iter.spikeWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),satDP:Integer=iter.satDP}	
	 						endif
		 				endif
	 				endif
	 			endif
	 		endif
	 	endif 	
) in result.satDP = 0-- there exists at least one spike occurrence that satisfies the amplitude predicate and violates the diagnostic pattern


				
-----------------------------
-- Functions for oscillations
-----------------------------

---------  Oscillations  ---------
def: isOscillation(subtrace:OrderedSet(trace::TraceElement),t1:trace::TraceElement, t2:trace::TraceElement,t3:trace::TraceElement,t4:trace::TraceElement,t5:trace::TraceElement,signal:sBTemPsy::Signal):Boolean= 
	(
					( isLocalMaximum(subtrace, t2, t1.generationTime, t3.generationTime, signal) and	
					 isLocalMinimum(subtrace, t3, t2.generationTime, t4.generationTime, signal) and
					 isLocalMaximum(subtrace, t4, t3.generationTime, t5.generationTime, signal) 
					)	
					or
				--max-min-max-min
					( isLocalMinimum(subtrace, t2, t1.generationTime, t3.generationTime, signal) and				
			      		isLocalMaximum(subtrace, t3, t2.generationTime, t4.generationTime, signal)  and
					 isLocalMinimum(subtrace, t4, t3.generationTime, t5.generationTime, signal) 
			  		)	
	 ) 	




----------------------------------------
--Auxiliary functions for oscillations--
----------------------------------------
-- auxiliary functions fordiagnostic patternof oscillations occurs: only one strict extremum in the signal
def: getTheOnlySeenExtremumOsc(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Oscillation, tl:Real,tu:Real):Sequence(Real)=
	let result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,oneStrictExtRecord:Sequence(Real)) = 
	trace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,oneStrictExtRecord:Sequence(Real)) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=trace->first(),up:Integer=0,down:Integer=0,oneStrictExtRecord:Sequence(Real)=Sequence{0,0}} -- it starts from the first index of the trace
	  	| 
	 let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	 in
 		-- iterate over all trace elements to check dp-spike-1
 		if iter.derivative=0 then
 			-- if positive derivative:
 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oneStrictExtRecord:Sequence(Real)=iter.oneStrictExtRecord} 
 			-- if derivative is negative: 
			else 
				if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
					Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oneStrictExtRecord:Sequence(Real)=iter.oneStrictExtRecord}
 				else 
 					-- case of flat signal:
 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oneStrictExtRecord:Sequence(Real)=iter.oneStrictExtRecord}					
 				endif
 			endif
 		else 
 			-- first extremum detected, missing strict local extremum
 			--if iter.derivative=1 then
	 			--1 case of strict maximum:  
				if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
			 		Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oneStrictExtRecord:Sequence(Real)=Sequence{iter.lastSeenRecord.generationTime,getValue(iter.lastSeenRecord,pattern.signal).val}}				
 				else -- signal still increasing:
 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
			 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oneStrictExtRecord:Sequence(Real)=iter.oneStrictExtRecord}				
 					else 
 					-- 2- case of strict minimum:
 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
			 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oneStrictExtRecord:Sequence(Real)=Sequence{iter.lastSeenRecord.generationTime,getValue(iter.lastSeenRecord,pattern.signal).val}}				
 						else 	-- signal still decreasing:
 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
			 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oneStrictExtRecord:Sequence(Real)=iter.oneStrictExtRecord}				
 							else 	
 								-- case of flat signal:
 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oneStrictExtRecord:Sequence(Real)=iter.oneStrictExtRecord}
 							endif
 						endif	
 					endif
 				endif
 		endif		
) in result.oneStrictExtRecord -- there exists exactly one strict extremum in the signal.


-- auxiliary functions for diagnostic pattern  of oscillations occurs: only one strict extremum in the signal
def: getTheTwoSeenExtremaOsc(trace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Oscillation, tl:Real,tu:Real):Sequence(Real)=
	let result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstExtDetected:Integer,strictExtRecords:Sequence(Real)) = 
	trace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstExtDetected:Integer,strictExtRecords:Sequence(Real)) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=trace->first(),up:Integer=0,down:Integer=0,firstExtDetected:Integer=0,strictExtRecords:Sequence(Real)=Sequence{0,0}} -- it starts from the first index of the trace
	  	| 
	 let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	 in
 		-- iterate over all trace elements to check dp-spike-1
 		if iter.derivative=0 then
 			-- if positive derivative:
 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstExtDetected:Integer=iter.firstExtDetected,strictExtRecords:Sequence(Real)=iter.strictExtRecords} 
 			-- if derivative is negative: 
			else 
				if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
					Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstExtDetected:Integer=iter.firstExtDetected,strictExtRecords:Sequence(Real)=iter.strictExtRecords}
 				else 
 					-- case of flat signal:
 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstExtDetected:Integer=iter.firstExtDetected,strictExtRecords:Sequence(Real)=iter.strictExtRecords}					
 				endif
 			endif
 		else 
 			-- if iter.derivative=1
 			-- first extremum detected, missing strict local extremum
	 			--1 case of strict maximum:  
				if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
					if iter.firstExtDetected = 0 then
			 			Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstExtDetected:Integer=1,strictExtRecords:Sequence(Real)=Sequence{(iter.lastSeenRecord.generationTime),(getValue(iter.lastSeenRecord,pattern.signal).val)}}	 			
 					else
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstExtDetected:Integer=2,strictExtRecords:Sequence(Real)=iter.strictExtRecords->append(iter.lastSeenRecord.generationTime)->append(getValue(iter.lastSeenRecord,pattern.signal).val)} 
 					endif			
 				else -- signal still increasing:
 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
			 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstExtDetected:Integer=iter.firstExtDetected,strictExtRecords:Sequence(Real)=iter.strictExtRecords}				
 					else 
 					-- 2- case of strict minimum:
 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
			 				if iter.firstExtDetected = 0 then
			 					Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstExtDetected:Integer=1,strictExtRecords:Sequence(Real)=Sequence{(iter.lastSeenRecord.generationTime),(getValue(iter.lastSeenRecord,pattern.signal).val)}}			
 							else
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstExtDetected:Integer=2,strictExtRecords:Sequence(Real)=iter.strictExtRecords->append(iter.lastSeenRecord.generationTime)->append(getValue(iter.lastSeenRecord,pattern.signal).val)}
							endif			 				
 						else 	-- signal still decreasing:
 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
			 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstExtDetected:Integer=iter.firstExtDetected,strictExtRecords:Sequence(Real)=iter.strictExtRecords}				
 							else 	
 								-- case of flat signal:
 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstExtDetected:Integer=iter.firstExtDetected,strictExtRecords:Sequence(Real)=iter.strictExtRecords}
 							endif
 						endif	
 					endif
 				endif
 		endif		
) in result.strictExtRecords -- there exists exactly one strict extremum in the signal.


--------------------------
-- oscillations diagnostic patterns
--------------------------
def: noOscFlatSignal(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real):Boolean=
	subtrace->forAll(t| 
	 		(t.generationTime >=tl and t.generationTime <=tu) implies getValue(t,pattern.signal).val=getValue(subtrace->first(),pattern.signal).val
	 		)
									 		
									 		
def: noOscSignalDecreases(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real):Boolean=
	subtrace->forAll(t1 | t1.generationTime >= tl and t1.generationTime < tu implies
			(
				subtrace-> forAll(t2| t2.generationTime > t1.generationTime and t2.generationTime <=tu implies
					getValue(t1,pattern.signal).val >= getValue(t2,pattern.signal).val					
				)
			))
																																	
def: noOscSignalIncreases(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real):Boolean=
	subtrace->forAll(t1 | t1.generationTime >= tl and t1.generationTime < tu implies
			(
				subtrace-> forAll(t2| t2.generationTime > t1.generationTime and t2.generationTime <=tu implies
					getValue(t1,pattern.signal).val <= getValue(t2,pattern.signal).val					
				)
			))
																				 		
def: noOscOneExtremum(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real):Boolean=
	let result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,numberOfStrictExtrema:Integer) = 
	subtrace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,numberOfStrictExtrema:Integer) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,numberOfStrictExtrema:Integer=0} -- it starts from the first index of the trace
	  	| 
	 let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	 in
	 	if iter.numberOfStrictExtrema > 1 then  -- stop checking all conditions once there exists at least one spike that does not violate the amplitude-based predicate
	 		Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema} 
	 	else 
	 		-- iterate over all trace elements to check dp-spike-1
	 		if iter.derivative=0 then
	 			-- if positive derivative:
	 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
	 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema} 
	 			-- if derivative is negative: 
 				else 
 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema} 
	 				else 
	 					-- case of flat signal:
	 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema}					
	 				endif
	 			endif
	 		else 
	 			-- first extremum detected, missing strict local extremum
	 			--if iter.derivative=1 then
		 			--1 case of strict maximum:  
				if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
			 		Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema+1}				
 				else -- signal still increasing:
 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
			 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema}				
 					else 
 					-- 2- case of strict minimum:
 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
			 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema+1}				
 						else 	-- signal still decreasing:
 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
			 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema}				
 							else 	
 								-- case of flat signal:
 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema}	
 							endif
 						endif	
 					endif
 				endif
	 		endif		
	 	endif 	
) in result.numberOfStrictExtrema = 1-- there exists exactly one strict extremum in the signal.


def: noOscTwoExtrema(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real):Boolean=
	let result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,numberOfStrictExtrema:Integer) = 
	subtrace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,numberOfStrictExtrema:Integer) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,numberOfStrictExtrema:Integer=0} -- it starts from the first index of the trace
	  	| 
	 let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	 in
	 	if iter.numberOfStrictExtrema > 2 then  -- stop checking all conditions once there exists at least one spike that does not violate the amplitude-based predicate
	 		Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema} 
	 	else 
	 		-- iterate over all trace elements to check dp-spike-1
	 		if iter.derivative=0 then
	 			-- if positive derivative:
	 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
	 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema} 
	 			-- if derivative is negative: 
 				else 
 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema} 
	 				else 
	 					-- case of flat signal:
	 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema}					
	 				endif
	 			endif
	 		else 
	 			-- first extremum detected, missing strict local extremum
	 			--if iter.derivative=1 then
		 			--1 case of strict maximum:  
				if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
			 		Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema+1}				
 				else -- signal still increasing:
 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
			 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema}				
 					else 
 					-- 2- case of strict minimum:
 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
			 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema+1}				
 						else 	-- signal still decreasing:
 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
			 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema}				
 							else 	
 								-- case of flat signal:
 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,numberOfStrictExtrema:Integer=iter.numberOfStrictExtrema}	
 							endif
 						endif	
 					endif
 				endif
	 		endif		
	 	endif 	
) in result.numberOfStrictExtrema = 2-- there exists exactly one strict extremum in the signal.

-----------------------------------------------------------------
-- diagnostic patterns and diagnostic information for oscillation
-----------------------------------------------------------------

def: oscillationsWithP2pViolation(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real,oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature),indAmp:Integer):Boolean=
	let result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstOscAmpl:Real,secondOscAmpl:Real,satDP:Integer) = 
	subtrace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstOscAmpl:Real,secondOscAmpl:Real,satDP:Integer) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,satDP:Integer=1} -- it starts from the first index of the trace
	  	| 
	 let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	 in
	 	if iter.satDP=0 then  -- stop checking all conditions once there exists at least one oscillation that does not violate the amplitude-based predicate
	 		Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,satDP:Integer=0} 
	 	else 
	 		-- iterate over all trace elements to check dp-oscillation-1
	 		if iter.derivative=0 then
	 			-- if positive derivative:
	 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
	 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,satDP:Integer=iter.satDP} 
	 			-- if derivative is negative: 
 				else 
 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=0,secondOscAmpl:Real=0,satDP:Integer=iter.satDP} 
	 				else 
	 					-- case of flat signal:
	 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=0,secondOscAmpl:Real=0,satDP:Integer=iter.satDP}					
	 				endif
	 			endif
	 		else  
	 			-- first extremum and first missing strict local extremum detected, missing last extremum:
					if iter.derivative=1 then	
						--1 case of local maximum: 
						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
							Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondOscAmpl:Real=0,satDP:Integer=iter.satDP}
						else 
							--2 case of local minimum: 
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
	 								Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondOscAmpl:Real=0,satDP:Integer=iter.satDP}
							else 
								--3 case of flat signal:
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,satDP:Integer=iter.satDP}
	 							else 
	 								-- signal still increasing or decreasing			
		 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,satDP:Integer=iter.satDP}		
		 						endif
			 				endif
		 				endif
		 			else --iter.derivative=2, missing last strict extremum
		 				if iter.derivative=2 then		
			 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
								Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),satDP:Integer=iter.satDP}
							else 
								--2 case of local minimum: 
								if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
									Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),satDP:Integer=iter.satDP}
								else 
									--3 case of flat signal:
		 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
	 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,satDP:Integer=iter.satDP}
		 							else 
		 								-- signal still increasing or decreasing			
			 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),secondOscAmpl:Real=iter.secondOscAmpl,satDP:Integer=iter.satDP}	
			 						endif
				 				endif
			 				endif
		 				else  
		 					--if iter.derivative=3 then		
			 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
			 					-- if the amplitude predicate is satisfied
			 					if oscAmpIsSat(iter.firstOscAmpl,pattern)=true or oscAmpIsSat(iter.secondOscAmpl,pattern)=true then
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,satDP:Integer=0}
								else
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,satDP:Integer=iter.satDP}
								endif	
							else 
								--2 case of local minimum: 
								if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
	 								-- if the amplitude predicate is satisfied
				 					if oscAmpIsSat(iter.firstOscAmpl,pattern)=true or oscAmpIsSat(iter.secondOscAmpl,pattern)=true then
										Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,satDP:Integer=0}
									else
										Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,satDP:Integer=iter.satDP}
									endif	
								else 
									--3 case of flat signal: --no oscillation
		 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
	 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,satDP:Integer=iter.satDP}
		 							else 
		 								-- signal still increasing or decreasing, recomputing the updated amplitude			
			 								Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),satDP:Integer=iter.satDP}			
			 						endif
				 				endif
			 				endif
		 				endif
		 			endif
	 			endif
	 		endif 	
	) in result.satDP = 0-- there exists at least one oscillation occurrence that satisfies the amplitude predicate and violates the diagnostic pattern	
	
	
def: p2pDiagnosticInformation(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real,oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature),indAmp:Integer):Sequence(Real)=
	let 
	ampThreshold:Real=oscFeaturesList->at(indAmp).oscFPred.value.val,
	result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstOscAmpl:Real,secondOscAmpl:Real,firstExtTimeStamp:Real,closestp2pToSat:Real,oscp2pInfos:Sequence(Real)) = 
	subtrace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstOscAmpl:Real,secondOscAmpl:Real,firstExtTimeStamp:Real,closestp2pToSat:Real,oscp2pInfos:Sequence(Real)) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=0,closestp2pToSat:Real=1000000000,oscp2pInfos:Sequence(Real)=Sequence{0,0,0}} -- it starts from the first index of the trace
	  	| 																																																				
	 let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	 in
 		-- iterate over all trace elements to check dp-oscillation-1
 		if iter.derivative=0 then
 			-- if positive derivative:
 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=Sequence{iter.lastSeenRecord.generationTime,iter.oscp2pInfos->at(2),iter.oscp2pInfos->at(3)}} 
 			-- if derivative is negative: 
			else 
				if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
					Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=Sequence{iter.lastSeenRecord.generationTime,iter.oscp2pInfos->at(2),iter.oscp2pInfos->at(3)}} 
 				else 
 					-- case of flat signal:
 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=Sequence{iter.oscp2pInfos->at(1),iter.oscp2pInfos->at(2),iter.oscp2pInfos->at(3)}}					
 				endif
 			endif
 		else  
 			-- first extremum and first missing strict local extremum detected, missing last extremum:
				if iter.derivative=1 then	
					--1 case of local maximum: 
					if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
						Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
					else 
						--2 case of local minimum: 
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 								Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
						else 
							--3 case of flat signal:
 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=0,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
 							else 
 								-- signal still increasing or decreasing			
	 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}		
	 						endif
		 				endif
	 				endif
	 			else --iter.derivative=2, missing last strict extremum
	 				if iter.derivative=2 then		
		 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
							Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
						else 
							--2 case of local minimum: 
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
								Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
							else 
								--3 case of flat signal:
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=0,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
	 							else 
	 								-- signal still increasing or decreasing			
		 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}	
		 						endif
			 				endif
		 				endif
	 				else  
	 					--if iter.derivative=3 then		
		 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
		 					-- if the amplitude predicate is satisfied
		 					if (iter.firstOscAmpl.max(iter.secondOscAmpl)-ampThreshold).abs() < (iter.closestp2pToSat-ampThreshold).abs() then
								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.firstOscAmpl.max(iter.secondOscAmpl),oscp2pInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,elem.generationTime,iter.firstOscAmpl.max(iter.secondOscAmpl)}}
							else
								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
							endif	
						else 
							--2 case of local minimum: 
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 								-- if the amplitude predicate is satisfied
			 					if (iter.firstOscAmpl.max(iter.secondOscAmpl)-ampThreshold).abs() < (iter.closestp2pToSat-ampThreshold).abs() then
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.firstOscAmpl.max(iter.secondOscAmpl),oscp2pInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,elem.generationTime,iter.firstOscAmpl.max(iter.secondOscAmpl)}}
								else
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
								endif	
							else 
								--3 case of flat signal: --no oscillation
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=0,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
	 							else 
	 								-- signal still increasing or decreasing, recomputing the updated amplitude			
		 								Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),firstExtTimeStamp:Real=iter.firstExtTimeStamp,closestp2pToSat:Real=iter.closestp2pToSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}			
		 						endif
			 				endif
		 				endif
	 				endif
	 			endif
 			endif 	
	) in result.oscp2pInfos -- diagnostic information about the closest oscillations to satisfying the p2p predicate
	
		
def: periodDiagnosticInformation(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real,oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature),indP:Integer):Sequence(Real)=
	let 
	periodThreshold:Real=oscFeaturesList->at(indP).oscFPred.value.val,
	result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,oscPeriod:Real,closestPeriod:Real,firstDetectedExt:Real,diagInfos:Sequence(Real)) = 
	subtrace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,oscPeriod:Real,closestPeriod:Real,firstDetectedExt:Real,diagInfos:Sequence(Real)) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,oscPeriod:Real=0,closestPeriod:Real=-1000000000,firstDetectedExt:Real=0,diagInfos:Sequence(Real)=Sequence{0,0,0}} -- it starts from the first index of the trace
	  	| 
	 let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	 in
 		-- iterate over all trace elements to check dp-oscillation-1
 		if iter.derivative=0 then
 			-- if positive derivative:
 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=0,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=iter.diagInfos} 
 			-- if derivative is negative: 
				else 
					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=0,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=iter.diagInfos} 
 				else 
 					-- case of flat signal:
 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=0,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}					
 				endif
 			endif
 		else  
 			-- first extremum and first missing strict local extremum detected, missing last extremum:
				if iter.derivative=1 then	
					--1 case of local maximum: 
					if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
						Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=elem.generationTime-iter.lastSeenRecord.generationTime,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
					else 
						--2 case of local minimum: 
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 								Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=elem.generationTime-iter.lastSeenRecord.generationTime,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
						else 
							--3 case of flat signal:
 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=0,diagInfos:Sequence(Real)=iter.diagInfos}
 							else 
 								-- signal still increasing or decreasing			
	 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}		
	 						endif
		 				endif
	 				endif
	 			else --iter.derivative=2, missing last strict extremum
	 				if iter.derivative=2 then		
		 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
							Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
						else 
							--2 case of local minimum: 
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
								Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
							else 
								--3 case of flat signal:
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=0,diagInfos:Sequence(Real)=iter.diagInfos}
	 							else 
	 								-- signal still increasing or decreasing			
		 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}	
		 						endif
			 				endif
		 				endif
	 				else  
	 					--if iter.derivative=3 then		
		 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
		 					-- if the current oscillation is the closest to satisfying the period predicate
		 					if (iter.oscPeriod-periodThreshold).abs() < (iter.closestPeriod-periodThreshold).abs()  then 
								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=iter.oscPeriod,closestPeriod:Real=iter.oscPeriod,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=Sequence{iter.firstDetectedExt,elem.generationTime,iter.oscPeriod}}
							else
								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=iter.oscPeriod,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=iter.diagInfos}
							endif	
						else 
							--2 case of local minimum: 
							-- if the current oscillation is the closest to satisfying the period predicate
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 								-- if the period predicate is satisfied
			 					if (iter.oscPeriod-periodThreshold).abs() < (iter.closestPeriod-periodThreshold).abs()  then 
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=iter.oscPeriod,closestPeriod:Real=iter.oscPeriod,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=Sequence{iter.firstDetectedExt,elem.generationTime,iter.oscPeriod}}
								else
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=iter.oscPeriod,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=iter.diagInfos}
								endif	
							else 
								--3 case of flat signal: --no oscillation
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
	 							else 
	 								-- signal still increasing or decreasing, recomputing the updated period			
	 								Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),closestPeriod:Real=iter.closestPeriod,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}			
		 						endif
			 				endif
		 				endif
	 				endif
	 			endif
 			endif 	
	) in result.diagInfos 
	
	

def: oscillationsWithPeriodViolation(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real,oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature),indP:Integer):Boolean=
	let result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,oscPeriod:Real,satDP:Integer) = 
	subtrace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,oscPeriod:Real,satDP:Integer) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,oscPeriod:Real=0,satDP:Integer=1} -- it starts from the first index of the trace
	  	| 
	 let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	 in
	 	if iter.satDP=0 then  -- stop checking all conditions once there exists at least one oscillation that does not violate the period-based predicate
	 		Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,satDP:Integer=0} 
	 	else 
	 		-- iterate over all trace elements to check dp-oscillation-1
	 		if iter.derivative=0 then
	 			-- if positive derivative:
	 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
	 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=0,satDP:Integer=iter.satDP} 
	 			-- if derivative is negative: 
 				else 
 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=0,satDP:Integer=iter.satDP} 
	 				else 
	 					-- case of flat signal:
	 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=0,satDP:Integer=iter.satDP}					
	 				endif
	 			endif
	 		else  
	 			-- first extremum and first missing strict local extremum detected, missing last extremum:
					if iter.derivative=1 then	
						--1 case of local maximum: 
						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
							Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=elem.generationTime-iter.lastSeenRecord.generationTime,satDP:Integer=iter.satDP}
						else 
							--2 case of local minimum: 
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
	 								Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=elem.generationTime-iter.lastSeenRecord.generationTime,satDP:Integer=iter.satDP}
							else 
								--3 case of flat signal:
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,satDP:Integer=iter.satDP}
	 							else 
	 								-- signal still increasing or decreasing			
		 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod,satDP:Integer=iter.satDP}		
		 						endif
			 				endif
		 				endif
		 			else --iter.derivative=2, missing last strict extremum
		 				if iter.derivative=2 then		
			 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
								Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),satDP:Integer=iter.satDP}
							else 
								--2 case of local minimum: 
								if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
									Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),satDP:Integer=iter.satDP}
								else 
									--3 case of flat signal:
		 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
	 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,satDP:Integer=iter.satDP}
		 							else 
		 								-- signal still increasing or decreasing			
			 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),satDP:Integer=iter.satDP}	
			 						endif
				 				endif
			 				endif
		 				else  
		 					--if iter.derivative=3 then		
			 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
			 					-- if the period predicate is satisfied
			 					if oscPeriodIsSat(iter.oscPeriod,pattern)=true then
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=iter.oscPeriod,satDP:Integer=0}
								else
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=iter.oscPeriod,satDP:Integer=iter.satDP}
								endif	
							else 
								--2 case of local minimum: 
								if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
	 								-- if the period predicate is satisfied
				 					if oscPeriodIsSat(iter.oscPeriod,pattern)=true  then
										Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=iter.oscPeriod,satDP:Integer=0}
									else
										Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=iter.oscPeriod,satDP:Integer=iter.satDP}
									endif	
								else 
									--3 case of flat signal: --no oscillation
		 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
	 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,satDP:Integer=iter.satDP}
		 							else 
		 								-- signal still increasing or decreasing, recomputing the updated period			
		 								Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),satDP:Integer=iter.satDP}			
			 						endif
				 				endif
			 				endif
		 				endif
		 			endif
	 			endif
	 		endif 	
	) in result.satDP = 0-- there exists at least one oscillation occurrence that satisfies the period predicate and violates the diagnostic pattern		
						

----------------------------------------------------------------
---- calling check* functions to check whether the cause pattern 
---- of the order relationship between signals holds -- 
----------------------------------------------------------------


---------  Data Assertion  ---------
def: checkStatePredicate(trace:OrderedSet(trace::TraceElement), element:trace::TraceElement, statePat:sBTemPsy::StateAssertion): Boolean = 
(		(statePat.dAPred.rOp = sBTemPsy::RelationalOperator::EQL and getValue(element,statePat.signal).val = statePat.dAPred.value.val) 		or
		(statePat.dAPred.rOp = sBTemPsy::RelationalOperator::LESS and getValue(element,statePat.signal).val < statePat.dAPred.value.val)  		or
		(statePat.dAPred.rOp = sBTemPsy::RelationalOperator::LESSEQ and getValue(element,statePat.signal).val <= statePat.dAPred.value.val) 	or
		(statePat.dAPred.rOp = sBTemPsy::RelationalOperator::GRT and getValue(element,statePat.signal).val > statePat.dAPred.value.val) 		or 
		(statePat.dAPred.rOp = sBTemPsy::RelationalOperator::GRTEQ and getValue(element,statePat.signal).val  >= statePat.dAPred.value.val) 	or
		(statePat.dAPred.rOp = sBTemPsy::RelationalOperator::DIFF and getValue(element,statePat.signal).val  <> statePat.dAPred.value.val)
)
----------------------------------------------------
-- optimized encoding of SB-TemPsy-Check constructs:
----------------------------------------------------

---------  Data Assertion  ---------
def: checkPatternDataAssertion(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, tl:Real,tu:Real):Boolean = 
	if trace->isEmpty() then true -- if no records in the trace
	else
	 	let dataassertion:sBTemPsy::DataAssertion=pattern.oclAsType(sBTemPsy::DataAssertion) in				
		
		if dataassertion.oclIsTypeOf(sBTemPsy::EventAssertion) then 
		( 	-- regular assertion 
			let eventAssertion:sBTemPsy::EventAssertion = dataassertion.oclAsType(sBTemPsy::EventAssertion) in
			
			-- paper encoding
			trace->forAll(t:trace::TraceElement | 
						(t.generationTime >= tl and t.generationTime <=tu) 
						implies 
						(checkCondition(trace, t, eventAssertion.condition))															     
						)
		)				
		else  --becomes
			if dataassertion.oclIsTypeOf(sBTemPsy::StateAssertion) then 
				let assertion:sBTemPsy::StateAssertion= pattern.oclAsType(sBTemPsy::StateAssertion), 
				res:Tuple(secondclause:Boolean,existsSecond:Boolean,result:Boolean) =
				trace -> iterate
					(	elem:trace::TraceElement;
						iter:Tuple(secondclause:Boolean,existsSecond:Boolean,result:Boolean) = 
						Tuple{secondclause:Boolean = true,existsSecond:Boolean=false, result:Boolean=false} 
						|	
							if	(checkStatePredicate(trace,elem,assertion) and iter.secondclause and iter.existsSecond) then
								Tuple{secondclause:Boolean = iter.secondclause,existsSecond:Boolean=iter.existsSecond, result:Boolean=true} 
							else
							 	if (checkStatePredicate(trace, elem, assertion)=false and iter.secondclause) then
							 		Tuple{secondclause:Boolean = iter.secondclause,existsSecond:Boolean=true, result:Boolean=iter.result}
							 	else
							 		Tuple{secondclause:Boolean = false,existsSecond:Boolean=true, result:Boolean=iter.result}
							 	endif
							endif		
					)
				in
				res.result
			else 
				false 
			endif
		endif	
	endif

---------  Spike Features  ---------	
def: spikeAmplitude(value1:Real,value2:Real,value3:Real,
	spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature),indAmp:Integer):Boolean= 
	 (	
	 	if spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::EQL then
	 	 (value2-value1).abs().max((value2-value3).abs()) = spikeFeaturesList->at(indAmp).sFPred.value.val 
		else
			if spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::GRT then
			 (value2-value1).abs().max((value2-value3).abs()) > spikeFeaturesList->at(indAmp).sFPred.value.val
			else
				if spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::LESS then
					 (value2-value1).abs().max((value2-value3).abs()) < spikeFeaturesList->at(indAmp).sFPred.value.val 
				else 
					if spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::GRTEQ then
					 	(value2-value1).abs().max((value2-value3).abs()) >= spikeFeaturesList->at(indAmp).sFPred.value.val
					else
						if spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::LESSEQ then
						 (value2-value1).abs().max((value2-value3).abs()) <= spikeFeaturesList->at(indAmp).sFPred.value.val
						else
							if spikeFeaturesList->at(indAmp).sFPred.rOp = sBTemPsy::RelationalOperator::DIFF then
							 (value2-value1).abs().max((value2-value3).abs()) <> spikeFeaturesList->at(indAmp).sFPred.value.val
							else
								false
							endif
						endif
					endif
				endif
			endif
		endif
		
	)
	
-- Define spike width note that t2 > t1 -- 
def: spikeWidth(t1:Real,t2:Real,spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature),indDur:Integer): Boolean= 
	(	if spikeFeaturesList->at(indDur).sFPred.rOp = sBTemPsy::RelationalOperator::EQL then
			 t2-t1 = spikeFeaturesList->at(indDur).sFPred.value.val
		else
			if spikeFeaturesList->at(indDur).sFPred.rOp = sBTemPsy::RelationalOperator::GRT then
				 t2-t1  > spikeFeaturesList->at(indDur).sFPred.value.val
			else
				if spikeFeaturesList->at(indDur).sFPred.rOp = sBTemPsy::RelationalOperator::LESS then
				 t2-t1  < spikeFeaturesList->at(indDur).sFPred.value.val
				 else
					if spikeFeaturesList->at(indDur).sFPred.rOp = sBTemPsy::RelationalOperator::GRTEQ then 
						t2-t1  >= spikeFeaturesList->at(indDur).sFPred.value.val
					else
						if spikeFeaturesList->at(indDur).sFPred.rOp = sBTemPsy::RelationalOperator::LESSEQ then
							 t2-t1  <= spikeFeaturesList->at(indDur).sFPred.value.val
						else
							if spikeFeaturesList->at(indDur).sFPred.rOp = sBTemPsy::RelationalOperator::DIFF then
							 t2-t1  <> spikeFeaturesList->at(indDur).sFPred.value.val
							else
								false
							endif
						endif
					endif
				endif
			endif
		endif
		
	)
					
def: checkSpikeFeatures(subtrace:OrderedSet(trace::TraceElement), spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature),t1:Real,t2:Real,t3:Real,t4:Real,v1:Real,v2:Real,v3:Real):Boolean=
	let
		indAmp:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::a),
		indP:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::w) 
	in
	if spikeFeaturesList.spkFName->includes(sBTemPsy::SpikeFeatureName::a) and  spikeFeaturesList.spkFName->includes(sBTemPsy::SpikeFeatureName::w) then
		spikeAmplitude(v1,v2,v3,spikeFeaturesList,indAmp) and spikeWidth(t2,t4,spikeFeaturesList,indP)
	else
		if spikeFeaturesList.spkFName->includes(sBTemPsy::SpikeFeatureName::a) then
			spikeAmplitude(v1,v2,v3,spikeFeaturesList,indAmp)
		else 
		 	true
		 endif 
		and
		if spikeFeaturesList.spkFName->includes(sBTemPsy::SpikeFeatureName::w) then
				spikeWidth(t2,t4,spikeFeaturesList,indP) 		
		else
			true
		 endif		
	endif	


def: checkMaxMinMaxSpike(subtrace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Pattern,tl:Real,tu:Real) :Boolean = 
	let 
	spkPattern:sBTemPsy::Spike=pattern.oclAsType(sBTemPsy::Spike),
	signal:sBTemPsy::Signal = spkPattern.signal,
	spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature)=spkPattern.spkFeat,
	initVal:sBTemPsy::Value=getValue(subtrace->at(0),signal),
	maxminmax:Tuple(t1:Real, t2:Real, t3:Real, t4:Real, t5:Real, v1:Real,v2:Real,v3:Real,lastValue:sBTemPsy::Value,lastGenerationTime:Real,result:Boolean) =
		subtrace -> iterate
			(	elem:trace::TraceElement;
				iter:Tuple(t1:Real, t2:Real, t3:Real, t4:Real, t5:Real, v1:Real,v2:Real,v3:Real, lastValue:sBTemPsy::Value,lastGenerationTime:Real,result:Boolean) = 
				Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=initVal,lastGenerationTime:Real=-1,result:Boolean=false} 
				|	
				let
					lastvalue:sBTemPsy::Value=getValue(elem,signal)
				in 
				if elem.generationTime>=tl and elem.generationTime<=tu then
					if iter.t1<0 then
						Tuple{t1:Real = elem.generationTime, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
					else
						if iter.t2<0 then
							-- the signal is going up
							if iter.lastValue.val<=lastvalue.val then
								Tuple{t1:Real = iter.t1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
							else
								Tuple{t1:Real = iter.t1, t2:Real = iter.lastGenerationTime, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = iter.lastValue.val, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
							endif
						else
							if iter.t3<0 then
								-- the signal is going down
								if iter.lastValue.val>=lastvalue.val and elem.generationTime<>tu then
									Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
								else
									if elem.generationTime<>tu then
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.lastGenerationTime, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									else
										if checkSpikeFeatures(subtrace, spikeFeaturesList,iter.t1,iter.t2,iter.lastGenerationTime,elem.generationTime,iter.v1,iter.lastValue.val,lastvalue.val) then
											-- Found match changing the result
											Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.lastGenerationTime, t4:Real = elem.generationTime, t5:Real = elem.generationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
										else
											Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
										endif
									endif
								endif
							else 
								if iter.t4<0 then
									-- the signal is going up
									if iter.lastValue.val<=lastvalue.val and elem.generationTime<>tu then
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									else
										if elem.generationTime<>tu then
											-- a maximum is detected
											Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.lastGenerationTime, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = iter.lastValue.val,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
										else
											if checkSpikeFeatures(subtrace, spikeFeaturesList,iter.t1,iter.t2,iter.t3,iter.lastGenerationTime,iter.v1,iter.v2,iter.lastValue.val) then
												-- Found match changing the result
												Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.lastGenerationTime, t5:Real = elem.generationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
											else
												Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
											endif
										endif 
										
									endif
								else
									if iter.t5<0 then
										-- the signal is going down
										if iter.lastValue.val>=lastvalue.val and elem.generationTime<>tu then
											Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = iter.v3,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
										else
											if checkSpikeFeatures(subtrace, spikeFeaturesList,iter.t1,iter.t2,iter.t3,iter.t4,iter.v1,iter.v2,iter.v3) then
												-- Found match changing the result
												Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = iter.lastGenerationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
											else
												
												Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
											endif
											
										endif
									else
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									endif
								endif
							endif
	
						endif 
					endif
				else
					Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real =iter.t3, t4:Real = iter.t4, t5:Real = iter.t5,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
				endif

			)
		in			
		maxminmax.result
						
def: checkMinMaxMinSpike(subtrace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Pattern,tl:Real,tu:Real) :Boolean = 
	let 
	spkPattern:sBTemPsy::Spike=pattern.oclAsType(sBTemPsy::Spike),
	signal:sBTemPsy::Signal = spkPattern.signal,
	spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature)=spkPattern.spkFeat,
	initVal:sBTemPsy::Value=getValue(subtrace->at(0),signal),
	minmaxmin:Tuple(t1:Real, t2:Real, t3:Real, t4:Real, t5:Real, v1:Real,v2:Real,v3:Real,lastValue:sBTemPsy::Value,lastGenerationTime:Real,result:Boolean) =
		subtrace -> iterate
			(	elem:trace::TraceElement;
				iter:Tuple(t1:Real, t2:Real, t3:Real, t4:Real, t5:Real, v1:Real,v2:Real,v3:Real, lastValue:sBTemPsy::Value,lastGenerationTime:Real,result:Boolean) = 
				Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=initVal,lastGenerationTime:Real=-1,result:Boolean=false} 
				|	
				let
					lastvalue:sBTemPsy::Value=getValue(elem,signal)
				in 
				if elem.generationTime>=tl and elem.generationTime<=tu then
					if iter.t1<0 then
						Tuple{t1:Real = elem.generationTime, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
					else
						if iter.t2<0 then
							-- the signal is going down
							if iter.lastValue.val>=lastvalue.val then
								Tuple{t1:Real = iter.t1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
							else
								-- a minimum is detected 
								Tuple{t1:Real = iter.t1, t2:Real = iter.lastGenerationTime, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = iter.lastValue.val, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
							endif
						else
							if iter.t3<0 then
								-- the signal is going up
								if iter.lastValue.val<=lastvalue.val and elem.generationTime<>tu then
									Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
								else
									if elem.generationTime<>tu then
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.lastGenerationTime, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									else
										if checkSpikeFeatures(subtrace, spikeFeaturesList,iter.t1,iter.t2,iter.lastGenerationTime,elem.generationTime,iter.v1,iter.lastValue.val,lastvalue.val) then
											-- Found match changing the result
											Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.lastGenerationTime, t4:Real = elem.generationTime, t5:Real = elem.generationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
										else
											Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
										endif
									endif
								endif
							else 
								if iter.t4<0 then
									-- the signal is going down
									if iter.lastValue.val>=lastvalue.val and elem.generationTime<>tu then
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									else
										if elem.generationTime<>tu then
											-- a minimum is detected
											Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.lastGenerationTime, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = iter.lastValue.val,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
										else
											if checkSpikeFeatures(subtrace, spikeFeaturesList,iter.t1,iter.t2,iter.t3,iter.lastGenerationTime,iter.v1,iter.v2,iter.lastValue.val) then
												-- Found match changing the result
												Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.lastGenerationTime, t5:Real = elem.generationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
											else
												Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
											endif
										endif 
									endif
								else
									if iter.t5<0 then
										-- the signal is going up
										if iter.lastValue.val<=lastvalue.val and elem.generationTime<>tu then
											Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = iter.v3,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
										else
											if checkSpikeFeatures(subtrace, spikeFeaturesList,iter.t1,iter.t2,iter.t3,iter.t4,iter.v1,iter.v2,iter.v3) then
												-- Found match changing the result
												Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = iter.lastGenerationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
											else
												
												Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
											endif
											
										endif
									else
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									endif
								endif
							endif
	
						endif 
					endif
				else
					Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real =iter.t3, t4:Real = iter.t4, t5:Real = iter.t5,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
				endif

			)
		in			
		minmaxmin.result			
---------  Spike  ---------	
def: checkPatternSpike(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,tl:Real,tu:Real):Boolean = 
if subtrace->isEmpty() then true -- if no records in the trace
else

	if subtrace->isEmpty() then true -- if no records in the trace
	else
		if checkMaxMinMaxSpike(subtrace,pattern,tl,tu) then
			true
		else 
			if checkMinMaxMinSpike(subtrace,pattern,tl,tu) then
				true
			else
				false
			endif
		endif
	endif
endif


--								
def: peakToPeakAmp(subtrace:OrderedSet(trace::TraceElement),  oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature),indAmp:Integer,v1:Real,v2:Real,v3:Real):Boolean=
	if oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::LESS then
		(v1-v2).abs()<oscFeaturesList->at(indAmp).oscFPred.value.val and
							 (v2-v3).abs()<oscFeaturesList->at(indAmp).oscFPred.value.val	
	else
		if oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::EQL then
			(v1-v2).abs()=oscFeaturesList->at(indAmp).oscFPred.value.val and
										 (v2-v3).abs()=oscFeaturesList->at(indAmp).oscFPred.value.val					 
		else
			if oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::GRT then
				(v1-v2).abs()>oscFeaturesList->at(indAmp).oscFPred.value.val and
								 (v2-v3).abs()>oscFeaturesList->at(indAmp).oscFPred.value.val	
			else
				if oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::GRTEQ then
					(v1-v2).abs()>=oscFeaturesList->at(indAmp).oscFPred.value.val and
											 (v2-v3).abs()>=oscFeaturesList->at(indAmp).oscFPred.value.val	
				else 
					if oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::LESSEQ then
					 (v1-v2).abs()<=oscFeaturesList->at(indAmp).oscFPred.value.val and
											 (v2-v3).abs()<=oscFeaturesList->at(indAmp).oscFPred.value.val	
					else
						if oscFeaturesList->at(indAmp).oscFPred.rOp = sBTemPsy::RelationalOperator::DIFF then
								(v1-v2).abs() <> oscFeaturesList->at(indAmp).oscFPred.value.val and
											 (v2-v3).abs()<>oscFeaturesList->at(indAmp).oscFPred.value.val	
						else
							false
						endif
					endif
				endif
			endif
		endif
	endif

	

				
				
def: period(subtrace:OrderedSet(trace::TraceElement), oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature),indP:Integer,t1:Real,t2:Real,t3:Real,t4:Real):Boolean=
	if oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::LESS then
		t4-t2<oscFeaturesList->at(indP).oscFPred.value.val 
	else
		if oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::EQL then
			(t2-t4).abs()=oscFeaturesList->at(indP).oscFPred.value.val
		else				 
			if oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::GRT then
				(t2-t4).abs()>oscFeaturesList->at(indP).oscFPred.value.val	
			else
				if oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::GRTEQ then
					(t2-t4).abs()>=oscFeaturesList->at(indP).oscFPred.value.val	
				else
					if oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::LESSEQ then
								(t2-t4).abs()<=oscFeaturesList->at(indP).oscFPred.value.val	
					else
						if oscFeaturesList->at(indP).oscFPred.rOp = sBTemPsy::RelationalOperator::DIFF then
									(t2-t4).abs() <> oscFeaturesList->at(indP).oscFPred.value.val
						else
							false
						endif
					endif
				endif	
			endif		
		endif	
	endif



def: checkOscillationFeatures(subtrace:OrderedSet(trace::TraceElement),  oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature),t1:Real,t2:Real,t3:Real,t4:Real,v1:Real,v2:Real,v3:Real):Boolean=
	let
		indAmp:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::a),
		indP:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::w)
	in
	if oscFeaturesList.oscFName->includes(sBTemPsy::OscillationsFeatureName::a)  and oscFeaturesList.oscFName->includes(sBTemPsy::OscillationsFeatureName::w) then
		peakToPeakAmp(subtrace,oscFeaturesList,indAmp,v1,v2,v3) and period(subtrace,oscFeaturesList,indP,t1,t2,t3,t4) 
	else
		if oscFeaturesList.oscFName->includes(sBTemPsy::OscillationsFeatureName::a) then
			peakToPeakAmp(subtrace,oscFeaturesList,indAmp,v1,v2,v3)
		else 
		 	true
		 endif 
		and
		if oscFeaturesList.oscFName->includes(sBTemPsy::OscillationsFeatureName::w) then
				period(subtrace,oscFeaturesList,indP,t1,t2,t3,t4) 		
		else
			true
		 endif
	endif


def: checkLocalMaxMinMaxOscillation(subtrace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Pattern,tl:Real,tu:Real) :Boolean = 
	let 
	oscPattern:sBTemPsy::Oscillation=pattern.oclAsType(sBTemPsy::Oscillation),
	signal:sBTemPsy::Signal = oscPattern.signal,
	oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature)=oscPattern.oscFeat,
	initVal:sBTemPsy::Value=getValue(subtrace->at(0),signal),
	maxminmax:Tuple(t1:Real, t2:Real, t3:Real, t4:Real, t5:Real, v1:Real,v2:Real,v3:Real,lastValue:sBTemPsy::Value,lastGenerationTime:Real,result:Boolean) =
		subtrace -> iterate
			(	elem:trace::TraceElement;
				iter:Tuple(t1:Real, t2:Real, t3:Real, t4:Real, t5:Real, v1:Real,v2:Real,v3:Real, lastValue:sBTemPsy::Value,lastGenerationTime:Real,result:Boolean) = 
				Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=initVal,lastGenerationTime:Real=-1,result:Boolean=false} 
				|	
				let
					lastvalue:sBTemPsy::Value=getValue(elem,signal)
				in 
				if elem.generationTime>=tl and elem.generationTime<=tu then
					if iter.t1<0 then
						Tuple{t1:Real = elem.generationTime, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
					else
						if iter.t2<0 then
							-- the signal is going up
							if iter.lastValue.val<lastvalue.val then
								Tuple{t1:Real = iter.t1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
							else
								if iter.lastValue.val=lastvalue.val then
									Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
								else
									-- a maximum is detected 
									Tuple{t1:Real = iter.t1, t2:Real = iter.lastGenerationTime, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = iter.lastValue.val, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
								endif 
							endif
						else
							if iter.t3<0 then
								-- the signal is going down
								if iter.lastValue.val>lastvalue.val then
									Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
								else
									if iter.lastValue.val=lastvalue.val then
										Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									else
										-- a minimum is detected
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.lastGenerationTime, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									endif
								endif
							else 
								if iter.t4<0 then
									-- the signal is going up
									if iter.lastValue.val<lastvalue.val then
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									else
										if iter.lastValue.val=lastvalue.val then
											Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
										else
											if elem.generationTime<>tu then
												-- a maximum is detected
												Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.lastGenerationTime, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = iter.lastValue.val,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
											else
												if checkOscillationFeatures(subtrace, oscFeaturesList,iter.t1,iter.t2,iter.t3,iter.lastGenerationTime,iter.v1,iter.v2,iter.lastValue.val) then
													-- Found match changing the result
													Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.lastGenerationTime, t5:Real = elem.generationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
												else
													Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
												endif
											endif 
										endif
									endif
								else
									if iter.t5<0 then
										-- the signal is going down
										if iter.lastValue.val>lastvalue.val and elem.generationTime<>tu then
											Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = iter.v3,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
										else
											if checkOscillationFeatures(subtrace, oscFeaturesList,iter.t1,iter.t2,iter.t3,iter.t4,iter.v1,iter.v2,iter.v3) then
												-- Found match changing the result
												Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = iter.lastGenerationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
											else
												
												Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
											endif
											
										endif
									else
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									endif
								endif
							endif
	
						endif 
					endif
				else
					Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real =iter.t3, t4:Real = iter.t4, t5:Real = iter.t5,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
				endif

			)
		in			
		maxminmax.result



def: checkLocalMinMaxMinOscillation(subtrace:OrderedSet(trace::TraceElement),pattern:sBTemPsy::Pattern,tl:Real,tu:Real) :Boolean = 
	let 
	oscPattern:sBTemPsy::Oscillation=pattern.oclAsType(sBTemPsy::Oscillation),
	signal:sBTemPsy::Signal = oscPattern.signal,
	oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature)=oscPattern.oscFeat,
	initVal:sBTemPsy::Value=getValue(subtrace->at(0),signal),
	minmaxmin:Tuple(t1:Real, t2:Real, t3:Real, t4:Real, t5:Real, v1:Real,v2:Real,v3:Real,lastValue:sBTemPsy::Value,lastGenerationTime:Real,result:Boolean) =
		subtrace -> iterate
			(	elem:trace::TraceElement;
				iter:Tuple(t1:Real, t2:Real, t3:Real, t4:Real, t5:Real, v1:Real,v2:Real,v3:Real, lastValue:sBTemPsy::Value,lastGenerationTime:Real,result:Boolean) = 
				Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=initVal,lastGenerationTime:Real=-1,result:Boolean=false} 
				|	
				let
					lastvalue:sBTemPsy::Value=getValue(elem,signal)
				in 
				if elem.generationTime>=tl and elem.generationTime<=tu then
					if iter.t1<0 then
						Tuple{t1:Real = elem.generationTime, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
					else
						if iter.t2<0 then
							-- the signal is going down
							if iter.lastValue.val>lastvalue.val then
								Tuple{t1:Real = iter.t1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
							else
								if iter.lastValue.val=lastvalue.val then
									Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
								else
									-- a minimum is detected 
									Tuple{t1:Real = iter.t1, t2:Real = iter.lastGenerationTime, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = iter.lastValue.val, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
								endif 
							endif
						else
							if iter.t3<0 then
								-- the signal is going up
								if iter.lastValue.val<lastvalue.val then
									Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
								else
									if iter.lastValue.val=lastvalue.val then
										Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									else
										-- a maximum is detected
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.lastGenerationTime, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									endif
								endif
							else 
								if iter.t4<0 then
									-- the signal is down up
									if iter.lastValue.val>lastvalue.val then
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = -1, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									else
										if iter.lastValue.val=lastvalue.val then
											Tuple{t1:Real = -1, t2:Real = -1, t3:Real = -1, t4:Real = -1, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
										else
											if elem.generationTime<>tu then
												-- a minimum is detected
												Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.lastGenerationTime, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = iter.lastValue.val,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
											else
												if checkOscillationFeatures(subtrace, oscFeaturesList,iter.t1,iter.t2,iter.t3,iter.lastGenerationTime,iter.v1,iter.v2,iter.lastValue.val) then
													-- Found match changing the result
													Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.lastGenerationTime, t5:Real = elem.generationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
												else
													Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
												endif
											endif 
										endif
									endif
								else
									if iter.t5<0 then
										-- the signal is going up
										if iter.lastValue.val>lastvalue.val and elem.generationTime<>tu then
											Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = -1,v1:Real = iter.v1, v2:Real = iter.v2, v3:Real = iter.v3,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
										else
											if checkOscillationFeatures(subtrace, oscFeaturesList,iter.t1,iter.t2,iter.t3,iter.t4,iter.v1,iter.v2,iter.v3) then
												-- Found match changing the result
												Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = iter.lastGenerationTime,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=true} 
											else
												
												Tuple{t1:Real = iter.t3, t2:Real = iter.t4, t3:Real = iter.t5, t4:Real = -1, t5:Real = -1,v1:Real = iter.v3, v2:Real = iter.lastValue.val, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
											endif
											
										endif
									else
										Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real = iter.t3, t4:Real = iter.t4, t5:Real = -1,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result} 
									endif
								endif
							endif
	
						endif 
					endif
				else
					Tuple{t1:Real = iter.t1, t2:Real = iter.t2, t3:Real =iter.t3, t4:Real = iter.t4, t5:Real = iter.t5,v1:Real = -1, v2:Real = -1, v3:Real = -1,lastValue:sBTemPsy::Value=lastvalue,lastGenerationTime:Real=elem.generationTime,result:Boolean=iter.result}
				endif

			)
		in			
		minmaxmin.result


def: checkPatternOscillations(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,tl:Real,tu:Real):Boolean = 
	if subtrace->isEmpty() then true -- if no records in the trace
	else
		if checkLocalMaxMinMaxOscillation(subtrace,pattern,tl,tu) then
			true
		else 
			if checkLocalMinMaxMinOscillation(subtrace,pattern,tl,tu) then
				true
			else
				false
			endif
		endif
	endif



---------  Rise time pattern  ---------
def: checkPatternRiseTime(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,tl:Real,tu:Real):Boolean = 
	let 
		rtPattern:sBTemPsy::Rise=pattern.oclAsType(sBTemPsy::Rise),
		signal:sBTemPsy::Signal = rtPattern.signal,
		--behavior:sBTemPsy::PatternType=rtPattern.rfBehavior, 
		targetVal:Real=rtPattern.targetValue.val,
		initVal:sBTemPsy::Value=getValue(subtrace->at(0),signal)
	in
	
	--	monotonicity constraint (if required)
	if rtPattern.rfMonotonicity = sBTemPsy::MonotonicityType::MONOTONICITY then 
	
		let result:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) =
	subtrace -> iterate
		(	elem:trace::TraceElement;
			iter:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) = 
			Tuple{result:Boolean=false,lowerThanv:Boolean=true,monotonicity:Boolean=true,lastValue:sBTemPsy::Value=initVal,isInitVal:Boolean=true} 
			|	
				let
					currentVal:sBTemPsy::Value=getValue(elem,signal)
				in 
				
				if elem.generationTime>=tl and elem.generationTime<=tu and iter.result=false then
					if currentVal.val >= targetVal then
						if iter.lowerThanv and iter.monotonicity then 
							Tuple{result:Boolean=true,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						else
							iter
						endif
					else
						if iter.isInitVal then
							Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=false}
						else
							if iter.lastValue.val < currentVal.val then
								Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
							else
								Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=false,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}								
							endif
						endif
					endif
				else
					iter
				endif
			) in
		result.result
		
	else
		let result:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) =
	subtrace -> iterate
		(	elem:trace::TraceElement;
			iter:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) = 
			Tuple{result:Boolean=false,lowerThanv:Boolean=true,monotonicity:Boolean=true,lastValue:sBTemPsy::Value=initVal,isInitVal:Boolean=true} 
			|	
				let
					currentVal:sBTemPsy::Value=getValue(elem,signal)
				in 
				
				if elem.generationTime>=tl and elem.generationTime<=tu and iter.result=false then
					if currentVal.val >= targetVal then
						if iter.lowerThanv and iter.monotonicity then 
							Tuple{result:Boolean=true,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						else
							iter
						endif
					else
						if iter.isInitVal then
							Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=false}
						else
							Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						endif
					endif
				else
					iter
				endif
			) in
		result.result
	endif		
	
	 
		
---------  Fall time pattern  ---------
def: checkPatternFallTime(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, tl:Real,tu:Real):Boolean = 
	let 
		rtPattern:sBTemPsy::Fall=pattern.oclAsType(sBTemPsy::Fall),
		signal:sBTemPsy::Signal = rtPattern.signal,
		--behavior:sBTemPsy::PatternType=rtPattern.rfBehavior, 
		targetVal:Real=rtPattern.targetValue.val,
		initVal:sBTemPsy::Value=getValue(subtrace->at(0),signal)
	in
		--	monotonicity constraint (if required)
	if rtPattern.rfMonotonicity = sBTemPsy::MonotonicityType::MONOTONICITY then 
	
		let result:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) =
	subtrace -> iterate
		(	elem:trace::TraceElement;
			iter:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) = 
			Tuple{result:Boolean=false,lowerThanv:Boolean=true,monotonicity:Boolean=true,lastValue:sBTemPsy::Value=initVal,isInitVal:Boolean=true} 
			|	
				let
					currentVal:sBTemPsy::Value=getValue(elem,signal)
				in 
				
				if elem.generationTime>=tl and elem.generationTime<=tu and iter.result=false then
					if currentVal.val <= targetVal then
						if iter.lowerThanv and iter.monotonicity then 
							Tuple{result:Boolean=true,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						else
							iter
						endif
					else
						if iter.isInitVal then
							Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=false}
						else
							if iter.lastValue.val > currentVal.val then
								Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
							else
								Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=false,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}								
							endif
						endif
					endif
				else
					iter
				endif
			) in
		result.result
		
	else
		let result:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) =
	subtrace -> iterate
		(	elem:trace::TraceElement;
			iter:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) = 
			Tuple{result:Boolean=false,lowerThanv:Boolean=true,monotonicity:Boolean=true,lastValue:sBTemPsy::Value=initVal,isInitVal:Boolean=true} 
			|	
				let
					currentVal:sBTemPsy::Value=getValue(elem,signal)
				in 
				
				if elem.generationTime>=tl and elem.generationTime<=tu and iter.result=false then
					if currentVal.val <= targetVal then
						if iter.lowerThanv and iter.monotonicity then 
							Tuple{result:Boolean=true,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						else
							iter
						endif
					else
						if iter.isInitVal then
							Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=false}
						else
							Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						endif
					endif
				else
					iter
				endif
			) in
		result.result
	endif		
	
	

	
------ Overshoot pattern ------
def: checkPatternOvershoot(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,tl:Real,tu:Real):Boolean = 
	let 
		oshPattern:sBTemPsy::Overshoot=pattern.oclAsType(sBTemPsy::Overshoot),
		signal:sBTemPsy::Signal = oshPattern.signal,
		--behavior:sBTemPsy::PatternType=oshPattern.ouBehavior, 
		targetVal:Real=oshPattern.targetValue.val,
		maxVal:Real=oshPattern.maximumValue.val,		
		initVal:sBTemPsy::Value=getValue(subtrace->at(0),signal)
	in
		--	monotonicity constraint (if required)
	if oshPattern.ouMonotonicity = sBTemPsy::MonotonicityType::MONOTONICITY then 
		let result:Tuple(result:Boolean,upperThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) =
	subtrace -> iterate
		(	elem:trace::TraceElement;
			iter:Tuple(result:Boolean,upperThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) = 
			Tuple{result:Boolean=false,upperThanv:Boolean=false,monotonicity:Boolean=true,lastValue:sBTemPsy::Value=initVal,isInitVal:Boolean=true} 
			|	
				let
					currentVal:sBTemPsy::Value=getValue(elem,signal)
				in 
				
				if elem.generationTime>=tl and elem.generationTime<=tu  then
					if iter.upperThanv then
						if currentVal.val<= targetVal+maxVal then
							Tuple{result:Boolean=iter.result,upperThanv:Boolean=iter.upperThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						else
							Tuple{result:Boolean=false,upperThanv:Boolean=iter.upperThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}	
						endif
					else
						if currentVal.val >= targetVal then
							if iter.monotonicity then 
								Tuple{result:Boolean=true,upperThanv:Boolean=true,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
							else
								iter
							endif
						else
							if iter.isInitVal then
								Tuple{result:Boolean=iter.result,upperThanv:Boolean=iter.upperThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=false}
							else
								if iter.lastValue.val < currentVal.val then
									Tuple{result:Boolean=iter.result,upperThanv:Boolean=iter.upperThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
								else
									Tuple{result:Boolean=iter.result,upperThanv:Boolean=iter.upperThanv,monotonicity:Boolean=false,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}								
								endif 
							endif
						endif
					endif
				else
					iter
				endif
			) in
		result.result
	else
		let result:Tuple(result:Boolean,upperThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) =
	subtrace -> iterate
		(	elem:trace::TraceElement;
			iter:Tuple(result:Boolean,upperThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) = 
			Tuple{result:Boolean=false,upperThanv:Boolean=false,monotonicity:Boolean=true,lastValue:sBTemPsy::Value=initVal,isInitVal:Boolean=true} 
			|	
				let
					currentVal:sBTemPsy::Value=getValue(elem,signal)
				in 
				
				if elem.generationTime>=tl and elem.generationTime<=tu then
					if iter.upperThanv then
						if currentVal.val<= targetVal+maxVal then
							Tuple{result:Boolean=iter.result,upperThanv:Boolean=iter.upperThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						else
							Tuple{result:Boolean=false,upperThanv:Boolean=iter.upperThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}	
						endif
					else
						if currentVal.val >= targetVal then
							if iter.monotonicity then 
								Tuple{result:Boolean=true,upperThanv:Boolean=true,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
							else
								iter
							endif
						else
							if iter.isInitVal then
								Tuple{result:Boolean=iter.result,upperThanv:Boolean=iter.upperThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=false}
							else
								iter
							endif
						endif
					endif
				else
					iter
				endif
			) in
		result.result
	endif


		
------ Undershoot pattern ------
def: checkPatternUndershoot(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,tl:Real,tu:Real):Boolean = 
	let 
		ushPattern:sBTemPsy::Undershoot=pattern.oclAsType(sBTemPsy::Undershoot),
		signal:sBTemPsy::Signal = ushPattern.signal,
		targetVal:Real=ushPattern.targetValue.val,
		maxVal:Real=ushPattern.maximumValue.val,		
		initVal:sBTemPsy::Value=getValue(subtrace->at(0),signal)
	in
		--	monotonicity constraint (if required)
	if ushPattern.ouMonotonicity = sBTemPsy::MonotonicityType::MONOTONICITY then 
		let result:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) =
	subtrace -> iterate
		(	elem:trace::TraceElement;
			iter:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) = 
			Tuple{result:Boolean=false,lowerThanv:Boolean=false,monotonicity:Boolean=true,lastValue:sBTemPsy::Value=initVal,isInitVal:Boolean=true} 
			|	
				let
					currentVal:sBTemPsy::Value=getValue(elem,signal)
				in 
				
				if elem.generationTime>=tl and elem.generationTime<=tu then
					if iter.lowerThanv then
						if currentVal.val>= targetVal-maxVal then
							Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						else
							Tuple{result:Boolean=false,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}	
						endif
					else
						if currentVal.val <= targetVal then
							if iter.monotonicity then 
								Tuple{result:Boolean=true,lowerThanv:Boolean=true,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
							else
								iter
							endif
						else
							if iter.isInitVal then
								Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=false}
							else
								if iter.lastValue.val > currentVal.val then
									Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
								else
									Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=false,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}								
								endif 
							endif
						endif
					endif
				else
					iter
				endif
			) in
		result.result
	else
		let result:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) =
	subtrace -> iterate
		(	elem:trace::TraceElement;
			iter:Tuple(result:Boolean,lowerThanv:Boolean,monotonicity:Boolean,lastValue:sBTemPsy::Value,isInitVal:Boolean) = 
			Tuple{result:Boolean=false,lowerThanv:Boolean=false,monotonicity:Boolean=true,lastValue:sBTemPsy::Value=initVal,isInitVal:Boolean=true} 
			|	
				let
					currentVal:sBTemPsy::Value=getValue(elem,signal)
				in 
				
				if elem.generationTime>=tl and elem.generationTime<=tu then
					if iter.lowerThanv then
						if currentVal.val>= targetVal-maxVal then
							Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
						else
							Tuple{result:Boolean=false,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}	
						endif
					else
						if currentVal.val <= targetVal  then
							if iter.monotonicity then 
								Tuple{result:Boolean=true,lowerThanv:Boolean=true,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=iter.isInitVal}
							else
								iter
							endif
						else
							if iter.isInitVal then
								Tuple{result:Boolean=iter.result,lowerThanv:Boolean=iter.lowerThanv,monotonicity:Boolean=iter.monotonicity,lastValue:sBTemPsy::Value=currentVal,isInitVal:Boolean=false}
							else
								iter
							endif
						endif
					endif
				else
					iter
				endif
			) in
		result.result
	endif















def: checkSinglePattern(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, firsttime:Real, lasttime:Real): Boolean=
	(pattern.oclIsTypeOf(sBTemPsy::StateAssertion) and checkPatternDataAssertion(trace, pattern,firsttime,lasttime)) or
	(pattern.oclIsTypeOf(sBTemPsy::EventAssertion) and checkPatternDataAssertion(trace, pattern,firsttime,lasttime)) or	
	(pattern.oclIsTypeOf(sBTemPsy::Spike) and checkPatternSpike(trace, pattern,firsttime,lasttime)) or
	(pattern.oclIsTypeOf(sBTemPsy::Oscillation) and checkPatternOscillations(trace, pattern,firsttime,lasttime)) or
	(pattern.oclIsTypeOf(sBTemPsy::Rise) and checkPatternRiseTime(trace, pattern,firsttime,lasttime)) or
	(pattern.oclIsTypeOf(sBTemPsy::Fall) and checkPatternFallTime(trace, pattern,firsttime,lasttime)) or
	(pattern.oclIsTypeOf(sBTemPsy::Overshoot) and checkPatternOvershoot(trace, pattern,firsttime,lasttime)) or
	(pattern.oclIsTypeOf(sBTemPsy::Undershoot) and checkPatternUndershoot(trace, pattern,firsttime,lasttime))  


def: checkPatternOrderRelationshipship(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,tl:Real,tu:Real): Boolean = 
	let 
	orderPattern:sBTemPsy::Order=pattern.oclAsType(sBTemPsy::Order),
	causePattern:sBTemPsy::Pattern=orderPattern.cause,
	causeEffectDistance:sBTemPsy::TimeDistance=orderPattern.causeEffectDistance,
	causeEffectDistanceCompOp:sBTemPsy::ComparingOperator=orderPattern.causeEffectDistance.comparingOperator,
	causeEffectDistanceBoundary:Real=orderPattern.causeEffectDistance.boundary.val,
	effectPatternsList:OrderedSet(sBTemPsy::Pattern)=orderPattern.effect.effectsPList
	in
	Set{1..trace->size()-1}->forAll(i | 
		if tl <= (trace->at(i)).generationTime and (trace->at(i)).generationTime <=tu  then
			Set{i..trace->size()-1} ->
				forAll(j | 
					if checkSinglePattern(trace,causePattern,(trace->at(i)).generationTime,(trace->at(j)).generationTime) and  (trace->at(j)).generationTime <=tu then
						effectPatternsList->forAll(p|
						Set{j..trace->size()-1} -> 
							exists(h |
								if causeEffectDistance <>null then 
									(	
										( causeEffectDistanceCompOp  = sBTemPsy::ComparingOperator::ATMOST and  (trace->at(h)).generationTime-(trace->at(j)).generationTime <= causeEffectDistanceBoundary) or
										( causeEffectDistanceCompOp  = sBTemPsy::ComparingOperator::ATLEAST and  (trace->at(h)).generationTime-(trace->at(j)).generationTime >= causeEffectDistanceBoundary) or
										( causeEffectDistanceCompOp  = sBTemPsy::ComparingOperator::EXACTLY and  (trace->at(h)).generationTime-(trace->at(j)).generationTime = causeEffectDistanceBoundary) 
									)
								else
									true
								endif
								and
								Set{h..trace->size()-1} ->
									exists(k |
										checkSinglePattern(trace,p,(trace->at(h)).generationTime,(trace->at(k)).generationTime) 
									)
							)
						)
					else
						true
					endif
				)
			
		else
			true
		endif
	) 

def: checkPattern(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, firsttime:Real, lasttime:Real): Boolean=
	if pattern.oclIsTypeOf(sBTemPsy::Order) then
		checkPatternOrderRelationshipship(trace, pattern,firsttime,lasttime)
	else
		checkSinglePattern(trace, pattern,firsttime,lasttime)
	endif

-------------------------------------------------------------------
-- Auxiliary functions for diagnostics information of order pattern 
-------------------------------------------------------------------

----------------------------------------  
-- diagnostic pattern: first record: t2
----------------------------------------  

def: getLastCauseRecordTimestamp(trace:OrderedSet(trace::TraceElement),causePattern:sBTemPsy::Pattern,effectPattern:sBTemPsy::Pattern, causeEffectDistanceCompOp:sBTemPsy::ComparingOperator,causeEffectDistanceBoundary:Real, tl:Real,tu:Real):trace::TraceElement=
	trace->select(t:trace::TraceElement | 
		trace->exists(t1,t2| t1.generationTime >=tl and
			t1.generationTime < t2.generationTime and t2.generationTime <tu and checkSinglePattern(trace,causePattern,t1.generationTime,t2.generationTime) and				
			t.generationTime = t2.generationTime
			 and
			trace->exists(t3,t4| 
			 t3.generationTime > t2.generationTime and t3.generationTime < t4.generationTime and t4.generationTime <=tu and
			checkSinglePattern(trace,effectPattern,t3.generationTime,t4.generationTime) implies 
				(			
					( causeEffectDistanceCompOp  = sBTemPsy::ComparingOperator::ATMOST and  t3.generationTime-t2.generationTime > causeEffectDistanceBoundary) or
					( causeEffectDistanceCompOp  = sBTemPsy::ComparingOperator::ATLEAST and  t3.generationTime-t2.generationTime < causeEffectDistanceBoundary) or
					( causeEffectDistanceCompOp  = sBTemPsy::ComparingOperator::EXACTLY and  t3.generationTime-t2.generationTime <> causeEffectDistanceBoundary) 
				)
			)
		)	
	)->last()

def: getCauseSignalName(trace:OrderedSet(trace::TraceElement),causePattern:sBTemPsy::Pattern,effectPattern:sBTemPsy::Pattern, causeEffectDistanceCompOp:sBTemPsy::ComparingOperator,causeEffectDistanceBoundary:Real, tl:Real,tu:Real):String=
	trace->select(t:trace::TraceElement | t.generationTime= getLastCauseRecordTimestamp(trace,causePattern,effectPattern,causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).generationTime
	).signalValue-> asSequence()->first().key.id



def: getLastCauseRecordNSEP(trace:OrderedSet(trace::TraceElement),causePattern:sBTemPsy::Pattern,effectPattern:sBTemPsy::Pattern, tl:Real,tu:Real):trace::TraceElement=
	trace->select(t:trace::TraceElement | 
	trace->exists(t1,t2| t1.generationTime >=tl and
		t1.generationTime < t2.generationTime and t2.generationTime <tu and checkSinglePattern(trace,causePattern,t1.generationTime,t2.generationTime)=true and				
		t.generationTime = t2.generationTime
		 and
		trace->forAll(t3,t4| 
		 t3.generationTime > t2.generationTime and t3.generationTime < t4.generationTime and t4.generationTime <=tu implies
		checkSinglePattern(trace,effectPattern,t3.generationTime,t4.generationTime)=false 
			)
		)	
	)->last()


----------------------------------------   
-- diagnostic pattern: second record: t3
----------------------------------------  


def: getEffect(trace:OrderedSet(trace::TraceElement),causePattern:sBTemPsy::Pattern,effectPatternsList:OrderedSet(sBTemPsy::Pattern), tl:Real,tu:Real):sBTemPsy::Pattern=
	effectPatternsList->select(p|
		trace->exists(t1,t2|t1.generationTime >= tl and t1.generationTime < t2.generationTime and t2.generationTime <tu and
					  checkSinglePattern(trace,causePattern,t1.generationTime,t2.generationTime)  and
		trace->exists(ta,tb | ta.generationTime >= t2.generationTime and ta.generationTime < tb.generationTime and tb.generationTime <=tu and 
				checkSinglePattern(trace,p,ta.generationTime,tb.generationTime)=false	
				and not trace->exists(tprime| tprime.generationTime > t2.generationTime and t2.generationTime <ta.generationTime and
							checkSinglePattern(trace,p,tprime.generationTime,ta.generationTime)=false
									 ) 			
					 )				 
					 )		
	)->first()

def: getFirstEffectRecordTimestamp(trace:OrderedSet(trace::TraceElement),causePattern:sBTemPsy::Pattern,effectPattern:sBTemPsy::Pattern, causeEffectDistanceCompOp:sBTemPsy::ComparingOperator,causeEffectDistanceBoundary:Real, tl:Real,tu:Real):trace::TraceElement=
	trace->select(t:trace::TraceElement | 
	trace->exists(t3,t4| t3.generationTime > getLastCauseRecordTimestamp(trace,causePattern,effectPattern,causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).generationTime 
					and  t3.generationTime < t4.generationTime and t4.generationTime <=tu and
						 t.generationTime =t3.generationTime	and
					checkSinglePattern(trace,effectPattern,t3.generationTime,t4.generationTime)=true
					and not (trace->exists(tprime| tprime.generationTime > getLastCauseRecordTimestamp(trace,causePattern,effectPattern,causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).generationTime and 
									tprime.generationTime < t3.generationTime and checkSinglePattern(trace,effectPattern,tprime.generationTime,t3.generationTime)=true
					)
					)
					)
	)->first()

def: getFirstEffectRecordValue(trace:OrderedSet(trace::TraceElement),causePattern:sBTemPsy::Pattern,effectPattern:sBTemPsy::Pattern, causeEffectDistanceCompOp:sBTemPsy::ComparingOperator,causeEffectDistanceBoundary:Real, tl:Real,tu:Real):Real=
	trace->select(t:trace::TraceElement | t.generationTime= getFirstEffectRecordTimestamp(trace,causePattern,effectPattern,causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).generationTime
	).signalValue-> asSequence()->first().value.val


def: getEffectSignalName(trace:OrderedSet(trace::TraceElement),causePattern:sBTemPsy::Pattern,effectPattern:sBTemPsy::Pattern, causeEffectDistanceCompOp:sBTemPsy::ComparingOperator,causeEffectDistanceBoundary:Real, tl:Real,tu:Real):String=
	trace->select(t:trace::TraceElement | t.generationTime= getFirstEffectRecordTimestamp(trace, causePattern, effectPattern, causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).generationTime).signalValue-> asSequence()->first().key.id


--------------------------------------------
-- get time distance between cause-effect --
--------------------------------------------
def: getOrderTimeDistance(trace:OrderedSet(trace::TraceElement),causePattern:sBTemPsy::Pattern,effectPattern:sBTemPsy::Pattern, causeEffectDistanceCompOp:sBTemPsy::ComparingOperator,causeEffectDistanceBoundary:Real, effectPatternsList:OrderedSet(sBTemPsy::Pattern), tl:Real,tu:Real):Real=
	(getFirstEffectRecordTimestamp(trace,causePattern,getEffect(trace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).generationTime - getLastCauseRecordTimestamp(trace,causePattern,effectPattern,causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).generationTime).abs() 		  


	-------******************------
	--			 PATTERNS
	------ ******************------	
	
-------------------
-- Data Assertion--
-------------------
def: reportPatternDataAssertion(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, tl:Real,tu:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if trace->isEmpty() then 			
			Set{Tuple{vSignal:String='Empty trace',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}}
		else		
	 		let dataassertion:sBTemPsy::DataAssertion=pattern.oclAsType(sBTemPsy::DataAssertion),
	 		recsDI:diagnostics::RecordDI=self.oclAsType(diagnostics::RecordDI),
	 		listOfRecords:OrderedSet(diagnostics::Record)=recsDI.records,	 		
	 		vSignal:String=recsDI.signalName,
			timestamp:Real=listOfRecords->at(1).timestamp,
			signalValue:Real=listOfRecords->at(1).signalValue,
			violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_assert_1
	 		in								
			if dataassertion.oclIsTypeOf(sBTemPsy::EventAssertion) then  -- event-based assertion
				(	 
				let eventAssertion:sBTemPsy::EventAssertion = dataassertion.oclAsType(sBTemPsy::EventAssertion) in		
				retrieveTargetAssertion(trace,eventAssertion.condition,tl,tu)		 				 
				)			
		else  -- state-based assertion
		if dataassertion.oclIsTypeOf(sBTemPsy::StateAssertion) then
			let assertion:sBTemPsy::StateAssertion= pattern.oclAsType(sBTemPsy::StateAssertion) in				
			 -- Case of  dp_becomes1: none of the records satisfies the predicate
			if 
				trace ->forAll(elem:trace::TraceElement | 
						(elem.generationTime > tl and elem.generationTime <=tu) 
						implies (reportStateViolatedPredicate(elem, assertion) 	)													     
						  )						 
			then 	
				Set{Tuple{vSignal:String=assertion.signal.id,
				  Records=Sequence{Tuple{
			  		timestamp:Real= getMinStateRecordV(trace,assertion,tl,tu).generationTime,
			  		signalValue:Real=getValue(getMinStateRecordV(trace,assertion,tl,tu),assertion.signal).val
			  		},
			  		Tuple{
			  		timestamp:Real= getMaxStateRecordV(trace,assertion,tl,tu).generationTime,
			  		signalValue:Real= getValue(getMaxStateRecordV(trace,assertion,tl,tu),assertion.signal).val
			  		}},
				  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
				  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_becomes_1
				}}			
			else  
			 		 -- Case of dp_becomes2: all records satisfy the predicate
			 	if 
					trace ->forAll(t:trace::TraceElement | 
						(t.generationTime> tl and t.generationTime <=tu) 
						implies (  
						trace ->exists(t1|
							t1.generationTime >= tl and 
							t1.generationTime < t.generationTime and
							 reportStateSatisfiedPredicate(t1, assertion)
								   ) 														     
							 )	
						 )					 
				then 		
					Set{Tuple{vSignal:String=assertion.signal.id,
					 		 Records=Sequence{Tuple{
					  		timestamp:Real=getMinStateRecordV(trace,assertion,tl,tu).generationTime,
					  		signalValue:Real=getValue(getMinStateRecordV(trace,assertion,tl,tu),assertion.signal).val
					  		},
					  		Tuple{
					  		timestamp:Real=getMinStateRecordV(trace,assertion,tl,tu).generationTime,
					  		signalValue:Real=getValue(getMinStateRecordV(trace,assertion,tl,tu),assertion.signal).val
					  		}},
						  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
						  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_becomes_2
						}}	
				else 
				-- Case of dp_becomes3: the signal satisfies the dual of the state-based data assertion instead --Check it!
					if 
						trace ->exists(t:trace::TraceElement | 
						(t.generationTime >tl and t.generationTime < tu) and 
						trace->forAll(t1| 
							(t1.generationTime>=tl and t1.generationTime < t.generationTime) implies  reportStateSatisfiedPredicate(t1, assertion)
								) and  
						 trace->forAll(t2| 
						(t2.generationTime >= t.generationTime and t2.generationTime <= tu) implies reportStateViolatedPredicate(t2, assertion)					
									  )
						)
					 then 
				 		Set{Tuple{vSignal:String=assertion.signal.id,
						  Records=Sequence{Tuple{
						  		timestamp:Real=reportDualStateAssertion(trace,assertion,tl,tu)->first().generationTime,
						  		signalValue:Real=getValue(reportDualStateAssertion(trace,assertion,tl,tu)->first(),assertion.signal).val
						  		},
						  		Tuple{
						  		timestamp:Real=reportDualStateAssertion(trace,assertion,tl,tu)->last().generationTime,
						  		signalValue:Real=getValue(reportDualStateAssertion(trace,assertion,tl,tu)->last(),assertion.signal).val
						  		}},
						  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
						  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_becomes_3
							    }}	
					 
					 else 
						 Set{Tuple{vSignal:String=getPatternSignalName(dataassertion),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
					 endif														
				endif	
		endif				
	else 
			Set{Tuple{vSignal:String=getPatternSignalName(dataassertion),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
		endif	
	
	endif	
	endif		

------------------------------
-- Transient Behaviors: DInfos 
------------------------------
---------------------------------------------------------------------------
-- Auxiliary functions for determining diagnostic information for Rise time
---------------------------------------------------------------------------
def: getMinInAbsenseOfRise(trace:OrderedSet(trace::TraceElement),rise:sBTemPsy::Rise,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, min:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,min:trace::TraceElement) = Tuple{index:Integer=0 ,min:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime<=tu and getValue(elem,rise.signal).val < getValue(iter.min,rise.signal).val then 
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=iter.min}
	    endif
	) in result.min

def: getMaxInAbsenseOfRise(trace:OrderedSet(trace::TraceElement),rise:sBTemPsy::Rise,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, max:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,max:trace::TraceElement) = Tuple{index:Integer=0 ,max:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime <=tu and getValue(elem,rise.signal).val > getValue(iter.max,rise.signal).val then 
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=iter.max}
	    endif
	) in result.max
	
---------------------------------------------------------------------------
-- Auxiliary functions for determining diagnostic information for Fall time
---------------------------------------------------------------------------
def: getMinInAbsenseOfFall(trace:OrderedSet(trace::TraceElement),fall:sBTemPsy::Fall,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, min:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,min:trace::TraceElement) = Tuple{index:Integer=0 ,min:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime<=tu and getValue(elem,fall.signal).val < getValue(iter.min,fall.signal).val then 
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=iter.min}
	    endif
	) in result.min

def: getMaxInAbsenseOfFall(trace:OrderedSet(trace::TraceElement),fall:sBTemPsy::Fall,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, max:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,max:trace::TraceElement) = Tuple{index:Integer=0 ,max:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime <=tu and getValue(elem,fall.signal).val > getValue(iter.max,fall.signal).val then 
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=iter.max}
	    endif
	) in result.max	

---------------------------------------------------------------------------
-- Auxiliary functions for determining diagnostic information for Overshoot
---------------------------------------------------------------------------
def: getMinInAbsenseOfOvershoot(trace:OrderedSet(trace::TraceElement),overshoots:sBTemPsy::Overshoot,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, min:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,min:trace::TraceElement) = Tuple{index:Integer=0 ,min:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime<=tu and getValue(elem,overshoots.signal).val < getValue(iter.min,overshoots.signal).val then 
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=iter.min}
	    endif
	) in result.min

def: getMaxInAbsenseOfOvershoot(trace:OrderedSet(trace::TraceElement),overshoots:sBTemPsy::Overshoot,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, max:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,max:trace::TraceElement) = Tuple{index:Integer=0 ,max:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime <=tu and getValue(elem,overshoots.signal).val > getValue(iter.max,overshoots.signal).val then 
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=iter.max}
	    endif
	) in result.max	
	
----------------------------------------------------------------------------
-- Auxiliary functions for determining diagnostic information for Undershoot
----------------------------------------------------------------------------
def: getMinInAbsenseOfUndershoot(trace:OrderedSet(trace::TraceElement),undershoots:sBTemPsy::Undershoot,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, min:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,min:trace::TraceElement) = Tuple{index:Integer=0 ,min:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime<=tu and getValue(elem,undershoots.signal).val < getValue(iter.min,undershoots.signal).val then 
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=iter.min}
	    endif
	) in result.min

def: getMaxInAbsenseOfUndershoot(trace:OrderedSet(trace::TraceElement),undershoots:sBTemPsy::Undershoot,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, max:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,max:trace::TraceElement) = Tuple{index:Integer=0 ,max:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime <=tu and getValue(elem,undershoots.signal).val > getValue(iter.max,undershoots.signal).val then 
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=iter.max}
	    endif
	) in result.max		

-------------------------------------------------
-- Diagnostic Information for transient behaviors
-------------------------------------------------
def: reportPatternRiseTime(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, tl:Real,tu:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if trace->isEmpty() then 
		Set{Tuple{vSignal:String='Empty trace',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}}
	 -- if no records in the trace
		else
	let 
		rtPattern:sBTemPsy::Rise=pattern.oclAsType(sBTemPsy::Rise),
		signal:sBTemPsy::Signal = rtPattern.signal in	
			--case of diagnostic pattern dp_rises1: non shown state: all signal values VIOLATE the predicate
			if 
				trace->forAll(t:trace::TraceElement | 
							    (t.generationTime>=tl and t.generationTime <=tu) implies
							    getValue(t,signal).val < rtPattern.targetValue.val 										     
							 )						 
			then 						
				Set{Tuple{vSignal:String=signal.id,
					  Records=Sequence{Tuple{
					  		timestamp:Real=getMinInAbsenseOfRise(trace,rtPattern,tl,tu).generationTime,
					  		signalValue:Real=getValue(getMinInAbsenseOfRise(trace,rtPattern,tl,tu),rtPattern.signal).val
					  		},
					  		Tuple{
					  		timestamp:Real=getMaxInAbsenseOfRise(trace,rtPattern,tl,tu).generationTime,
					  		signalValue:Real=getValue(getMaxInAbsenseOfRise(trace,rtPattern,tl,tu),rtPattern.signal).val
					  		}},
					  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
					  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_rises_1
					}}					
			else 
				-- case of diagnostic pattern dp_rises2: non shown state: all signal values satisfy the predicate
					if 								
						trace->forAll(t:trace::TraceElement | 
							(t.generationTime>=tl and t.generationTime <=tu) implies
							 getValue(t,signal).val >= rtPattern.targetValue.val 													     
							 )				 					 
					then 		
						Set{Tuple{vSignal:String=signal.id,
						  Records=Sequence{Tuple{
					  		timestamp:Real=getMinInAbsenseOfRise(trace,rtPattern,tl,tu).generationTime,
					  		signalValue:Real=getValue(getMinInAbsenseOfRise(trace,rtPattern,tl,tu),rtPattern.signal).val
					  		},
					  		Tuple{
					  		timestamp:Real=getMaxInAbsenseOfRise(trace,rtPattern,tl,tu).generationTime,
					  		signalValue:Real=getValue(getMaxInAbsenseOfRise(trace,rtPattern,tl,tu),rtPattern.signal).val
						  		}},
						  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
						  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_rises_2
							}}						
					else 
						 -- case of diagnostic pattern dp_rises4:
						if 
							trace->exists(t:trace::TraceElement | 
								t.generationTime > tl and t.generationTime < tu and 
						    trace->forAll(t1:trace::TraceElement |	
						    ((t.generationTime>=tl and t1.generationTime < t.generationTime) implies getValue(t1,signal).val>=rtPattern.targetValue.val	)
						    )
						     and
						     trace->forAll(t2:trace::TraceElement |	
						     ((t2.generationTime>=t.generationTime and t2.generationTime <= tu) implies getValue(t2,signal).val < rtPattern.targetValue.val	)					     
							)) 
									 
						then 	
							 Set{Tuple{vSignal:String=signal.id,
								  Records=Sequence{Tuple{
						  		timestamp:Real=reportDualRiseTime(trace,rtPattern,tl,tu)->first().generationTime,
						  		signalValue:Real=getValue(reportDualRiseTime(trace,rtPattern,tl,tu)->first(),rtPattern.signal).val
						  		},
						  		Tuple{
						  		timestamp:Real=reportDualRiseTime(trace,rtPattern,tl,tu)->last().generationTime,
						  		signalValue:Real=getValue(reportDualRiseTime(trace,rtPattern,tl,tu)->last(),rtPattern.signal).val
						  		}},
								  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
								  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_rises_4
									}}						
						else 
							-- case of diagnostic pattern dp_rises3: non satisfaction of the monotonicity constraint
							if rtPattern.rfMonotonicity = sBTemPsy::MonotonicityType::MONOTONICITY then   
								if 
									trace->exists(t| 
								    	(t.generationTime > tl and t.generationTime <=tu and 
								    getValue(t,signal).val >= rtPattern.targetValue.val
								   and 	trace->forAll( t1| 
								   (t1.generationTime >=tl and t1.generationTime <t.generationTime) implies
								   	getValue(t1,signal).val < rtPattern.targetValue.val
						   					)
								   	and 
								    not (trace->forAll(t2|
									    	t2.generationTime >= tl and t2.generationTime < t.generationTime implies
									    	(
								    		trace->forAll(t3|
								    			(t3.generationTime > t2.generationTime and t3.generationTime <= t.generationTime) implies
								    			getValue(t2,signal).val < getValue(t3,signal).val 
								    		)
									    	)
							    				) 
								    	)
									 	)	
									 )					 
								then 							
									Set{Tuple{vSignal:String=signal.id,
									  Records=Sequence{Tuple{
							  		timestamp:Real=reportMonotonicityViolationRiseTime(trace,rtPattern,tl,tu)->first().generationTime,
							  		signalValue:Real=getValue(reportMonotonicityViolationRiseTime(trace,rtPattern,tl,tu)->first(),rtPattern.signal).val
							  		},
							  		Tuple{
							  		timestamp:Real=reportMonotonicityViolationRiseTime(trace,rtPattern,tl,tu)->last().generationTime,
							  		signalValue:Real=getValue(reportMonotonicityViolationRiseTime(trace,rtPattern,tl,tu)->last(),rtPattern.signal).val
							  		}},
									  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
									  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_rises_3
										}}	
									
							else 
									Set{Tuple{vSignal:String=getPatternSignalName(rtPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
								endif
						else 
							Set{Tuple{vSignal:String=getPatternSignalName(rtPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
				endif 
			 endif
		   endif
	    endif				 							 	
	 endif

---------------
-- Fall Time --
---------------			 
def: reportPatternFallTime(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, tl:Real,tu:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if trace->isEmpty() then 
		Set{Tuple{vSignal:String='Empty trace',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}}
	 -- if no records in the trace
		else
	let 
		ftPattern:sBTemPsy::Fall=pattern.oclAsType(sBTemPsy::Fall),
		signal:sBTemPsy::Signal = ftPattern.signal in	
			--case of diagnostic patterndiagnostic pattern : non shown state: all signal values are above the predicate value
				if 
					trace->forAll(t:trace::TraceElement | 
								(t.generationTime>=tl and t.generationTime <=tu) implies								
							    getValue(t,signal).val >= ftPattern.targetValue.val 										     
								 )							 
				then 			
					Set{Tuple{vSignal:String=signal.id,
					  Records=Sequence{Tuple{
			  		  timestamp:Real=getMinInAbsenseOfFall(trace,ftPattern,tl,tu).generationTime,
				  		signalValue:Real=getValue(getMinInAbsenseOfFall(trace,ftPattern,tl,tu),ftPattern.signal).val
				  		},
				  		Tuple{
				  		timestamp:Real=getMaxInAbsenseOfFall(trace,ftPattern,tl,tu).generationTime,
				  		signalValue:Real=getValue(getMaxInAbsenseOfFall(trace,ftPattern,tl,tu),ftPattern.signal).val
				  		}},
					  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
					  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_falls_1
					  }}					
				else 
					-- case of diagnostic pattern: non shown state: all signal values are below the predicate value
						if 
							trace->forAll(t:trace::TraceElement | 
								(t.generationTime>=tl and t.generationTime <=tu) implies			
											 getValue(t,signal).val < ftPattern.targetValue.val 													     
										 )				 
						then 		
							Set{Tuple{vSignal:String=signal.id,
						    Records=Sequence{Tuple{
				  			timestamp:Real=getMinInAbsenseOfFall(trace,ftPattern,tl,tu).generationTime,--getMinRTRecordV(trace,rtPattern,tl,tu).generationTime,
					  		signalValue:Real=getValue(getMinInAbsenseOfFall(trace,ftPattern,tl,tu),ftPattern.signal).val
					  		},
					  		Tuple{
					  		timestamp:Real=getMaxInAbsenseOfFall(trace,ftPattern,tl,tu).generationTime,
					  		signalValue:Real=getValue(getMaxInAbsenseOfFall(trace,ftPattern,tl,tu),ftPattern.signal).val
						  		}},
								  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
								  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_falls_2
								}}					
						else 
							 -- case of diagnostic pattern diagnostic pattern: shown dual state
							if  
								trace->exists(t:trace::TraceElement | 
									(t.generationTime>tl and t.generationTime <tu) and			
									trace->forAll(t1:trace::TraceElement |
								     (t1.generationTime>=tl and t1.generationTime <t.generationTime) implies				
								     getValue(t1,signal).val < ftPattern.targetValue.val
								     	 ) and
								     trace->forAll(t2:trace::TraceElement |
								     	(t2.generationTime>=t.generationTime and t2.generationTime <=tu) implies				
								     getValue(t2,signal).val >= ftPattern.targetValue.val						     
										)) 
							then 	
								 Set{Tuple{vSignal:String=signal.id,
								  Records=Sequence{Tuple{
							  		timestamp:Real=reportDualFallTime(trace,ftPattern,tl,tu)->first().generationTime,
							  		signalValue:Real=getValue(reportDualFallTime(trace,ftPattern,tl,tu)->first(),ftPattern.signal).val
							  		},
							  		Tuple{
							  		timestamp:Real=reportDualFallTime(trace,ftPattern,tl,tu)->last().generationTime,
							  		signalValue:Real=getValue(reportDualFallTime(trace,ftPattern,tl,tu)->last(),ftPattern.signal).val
							  		}},
									  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
									  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_falls_4
									}}			
								 
							else 
								-- case of diagnostic patterndiagnostic pattern : non satisfaction of the monotonicity constraint
								if ftPattern.rfMonotonicity = sBTemPsy::MonotonicityType::MONOTONICITY then   
										if 	
											trace->exists(t| 
										    ( t.generationTime > tl and t.generationTime <= tu and 
										    getValue(t,signal).val < ftPattern.targetValue.val 
										   and 	trace->forAll(t1|
										   		(t1.generationTime>=tl and t1.generationTime < t.generationTime) implies
										   		getValue(t1,signal).val >= ftPattern.targetValue.val
										   		)
										   and 	
										   not (trace->forAll(t2|
											    	t2.generationTime >= tl and t2.generationTime < t.generationTime implies
											    	(
											    		trace->forAll(t3|
											    			(t3.generationTime > t2.generationTime and t3.generationTime <= t.generationTime) implies
											    			getValue(t2,signal).val >= getValue(t3,signal).val 
											    		)
											    	)
										    				) 
										    	)
											  ))					 								
										then  		
											Set{Tuple{vSignal:String=signal.id,
											  Records=Sequence{Tuple{
									  		timestamp:Real=reportMonotonicityViolationFallTime(trace,ftPattern,tl,tu)->first().generationTime,
									  		signalValue:Real=getValue(reportMonotonicityViolationFallTime(trace,ftPattern,tl,tu)->first(),ftPattern.signal).val
									  		},
									  		Tuple{
									  		timestamp:Real=reportMonotonicityViolationFallTime(trace,ftPattern,tl,tu)->last().generationTime,
									  		signalValue:Real=getValue(reportMonotonicityViolationFallTime(trace,ftPattern,tl,tu)->last(),ftPattern.signal).val
									  		}},
										  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
										  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_falls_3
										}}	
											
										else 
											Set{Tuple{vSignal:String=getPatternSignalName(ftPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
										endif
								else 
											Set{Tuple{vSignal:String=getPatternSignalName(ftPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
							endif 
				endif
			endif
		 endif		 								 	
    endif

---------------
-- Overshoot --
---------------

def: reportPatternOvershoot(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, tl:Real,tu:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if trace->isEmpty() then 
		Set{Tuple{vSignal:String='Empty trace',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}}
	 -- if no records in the trace
		else
		let 
		oshPattern:sBTemPsy::Overshoot=pattern.oclAsType(sBTemPsy::Overshoot),
		signal:sBTemPsy::Signal = oshPattern.signal,
		targetVal:Real=oshPattern.targetValue.val,
		maxVal:Real=oshPattern.maximumValue.val	
		in
	--case of diagnostic pattern dp_overshoots1: non shown state: all signal values violate the predicate 
		if 
			trace->forAll(t:trace::TraceElement |   
				(t.generationTime >=tl and t.generationTime <=tu) implies
			    getValue(t,signal).val < targetVal										     
						 )						 
		then 				
			Set{Tuple{vSignal:String=signal.id,
			 Records=Sequence{Tuple{
  			 timestamp:Real=getMinInAbsenseOfOvershoot(trace,oshPattern,tl,tu).generationTime,--getMinRTRecordV(trace,rtPattern,tl,tu).generationTime,
	  		 signalValue:Real=getValue(getMinInAbsenseOfOvershoot(trace,oshPattern,tl,tu),oshPattern.signal).val
	  		 },
	  		 Tuple{
	  		 timestamp:Real=getMaxInAbsenseOfOvershoot(trace,oshPattern,tl,tu).generationTime,
	  		 signalValue:Real=getValue(getMaxInAbsenseOfOvershoot(trace,oshPattern,tl,tu),oshPattern.signal).val
		  		}},
		  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
		  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_overshoots_1
			 }}	
		
		else 							
			if  -- diagnostic pattern dp_overshoots2: the signal overshoots targetVal but exceeds maxVal!
			 trace->exists(t:trace::TraceElement | 
			 	t.generationTime >=tl and t.generationTime <=tu and  
				getValue(t,signal).val > targetVal+maxVal and
				trace->forAll(t1:trace::TraceElement| 
					(t1.generationTime > t.generationTime and t1.generationTime <=tu) implies
				 getValue(t1,signal).val > targetVal+maxVal	
							 )
						    )		
				
			then 
					Set{Tuple{vSignal:String=signal.id,
					 Records=Sequence{Tuple{
		  			 timestamp:Real=getMinInAbsenseOfOvershoot(trace,oshPattern,tl,tu).generationTime,
			  		 signalValue:Real=getValue(getMinInAbsenseOfOvershoot(trace,oshPattern,tl,tu),oshPattern.signal).val
			  		 },
			  		 Tuple{
			  		 timestamp:Real=getMaxInAbsenseOfOvershoot(trace,oshPattern,tl,tu).generationTime,
			  		 signalValue:Real=getValue(getMaxInAbsenseOfOvershoot(trace,oshPattern,tl,tu),oshPattern.signal).val
					  		}},
					  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
					  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_overshoots_2
					 }}		  
			else			
				if --diagnostic pattern dp_overshoots4: the signal undershoots, instead of overshooting, showing the dual behavior
					(
					trace->exists(t|
						t.generationTime > tl and t.generationTime <=tu and 
						trace->forAll(t1|
						(t1.generationTime>=tl and t1.generationTime <=t.generationTime) implies
						getValue(t1,signal).val >= targetVal and getValue(t1,signal).val<= targetVal+maxVal
							)
						 and
						trace->forAll(t2| 
						(t2.generationTime > t.generationTime and t2.generationTime <=tu) implies									
						getValue(t2,signal).val < targetVal  
						)
						)
					)		
							
				then
					Set{Tuple{vSignal:String=signal.id,
						 Records=Sequence{Tuple{
						 timestamp:Real=reportDualOvershoot(trace,oshPattern,tl,tu)->first().generationTime,
						 signalValue:Real=getValue(reportDualOvershoot(trace,oshPattern,tl,tu)->first(),signal).val
						  },
					Tuple{
					  		timestamp:Real=reportDualOvershoot(trace,oshPattern,tl,tu)->last().generationTime,
						 signalValue:Real=getValue(reportDualOvershoot(trace,oshPattern,tl,tu)->last(),signal).val
					  		}},
					  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
					  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_overshoots_4
					 }}	
					
				else  
					-- diagnostic pattern3: non shown monotonicity constraint 
					if oshPattern.ouMonotonicity = sBTemPsy::MonotonicityType::MONOTONICITY then   
						if 
							trace->exists(t|
								t.generationTime > tl and t.generationTime <=tu and 
								getValue(t,signal).val >= targetVal and getValue(t,signal).val <= targetVal+maxVal and 
							trace->forAll(t2|
								(t2.generationTime >= tl and t2.generationTime <t.generationTime) implies 
								getValue(t2,signal).val <= targetVal
								) 
								and 
								trace->forAll(t1|
								(t1.generationTime >= t.generationTime and t1.generationTime <=tu) implies 
								getValue(t1,signal).val <= targetVal+maxVal
								) 
								and
									not(
										trace->forAll(t3| t3.generationTime >=tl and t3.generationTime < t.generationTime implies
											trace->forAll(t4| t4.generationTime> t3.generationTime and t4.generationTime <=t.generationTime implies
												getValue(t3,signal).val < getValue(t4,signal).val	
											)
													 )
										)
								) 						 
						then 		
							Set{Tuple{vSignal:String=signal.id,
								 Records=Sequence{Tuple{
								 timestamp:Real=reportMonotonicityViolationOvershoot(trace,oshPattern,tl,tu)->first().generationTime,
								 signalValue:Real=getValue(reportMonotonicityViolationOvershoot(trace,oshPattern,tl,tu)->first(),signal).val
								  },
								 Tuple{
							  		timestamp:Real=reportMonotonicityViolationOvershoot(trace,oshPattern,tl,tu)->last().generationTime,
								 	signalValue:Real=getValue(reportMonotonicityViolationOvershoot(trace,oshPattern,tl,tu)->last(),signal).val
							  		}},
							  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
							  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_overshoots_3
							 }}	
							
						else 
									Set{Tuple{vSignal:String=getPatternSignalName(oshPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
								endif
						else 
									Set{Tuple{vSignal:String=getPatternSignalName(oshPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
					endif 
				endif	 		 
			endif
		endif	
	endif	
	

---------------
-- Undershoot --
---------------
def: reportPatternUndershoot(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, tl:Real,tu:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if trace->isEmpty() then 
		Set{Tuple{vSignal:String='Empty trace',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}}
	 -- if no records in the trace
		else
		let 
		ushPattern:sBTemPsy::Undershoot=pattern.oclAsType(sBTemPsy::Undershoot),
		signal:sBTemPsy::Signal = ushPattern.signal,
		targetVal:Real=ushPattern.targetValue.val,
		maxVal:Real=ushPattern.maximumValue.val	
		in
			--case of diagnostic patterndiagnostic pattern : non shown state: all signal values violate the predicate 
				if 
					trace->forAll(t:trace::TraceElement |   
								(t.generationTime >=tl and t.generationTime <=tu) implies
								    getValue(t,signal).val >= targetVal										     
								 )				  							 
				then 		
					Set{Tuple{vSignal:String=signal.id,
						 Records=Sequence{Tuple{
			  			 timestamp:Real=getMinInAbsenseOfUndershoot(trace,ushPattern,tl,tu).generationTime,
				  		 signalValue:Real=getValue(getMinInAbsenseOfUndershoot(trace,ushPattern,tl,tu),ushPattern.signal).val
				  		 },
				  		 Tuple{
				  		 timestamp:Real=getMaxInAbsenseOfUndershoot(trace,ushPattern,tl,tu).generationTime,
				  		 signalValue:Real=getValue(getMaxInAbsenseOfUndershoot(trace,ushPattern,tl,tu),ushPattern.signal).val
					  		}},
					  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
					  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_undershoots_1
							 }}						
				else 		
								
					if  --diagnostic patterndiagnostic pattern : the signal undershoots targetVal but goes below targetVal-maxVal!											    
						trace->exists(t:trace::TraceElement | 
					 	t.generationTime >=tl and t.generationTime <=tu and  
						getValue(t,signal).val < targetVal-maxVal.abs() and
						trace->forAll(t1:trace::TraceElement| 
							(t1.generationTime > t.generationTime and t1.generationTime <=tu) implies
						 getValue(t1,signal).val < targetVal-maxVal.abs()	
									 )
								    )		    				    	
					then 
							Set{Tuple{vSignal:String=signal.id,
								 Records=Sequence{Tuple{
					  			 timestamp:Real=getMinInAbsenseOfUndershoot(trace,ushPattern,tl,tu).generationTime,
						  		 signalValue:Real=getValue(getMinInAbsenseOfUndershoot(trace,ushPattern,tl,tu),ushPattern.signal).val
						  		 },
						  		 Tuple{
						  		 timestamp:Real=getMaxInAbsenseOfUndershoot(trace,ushPattern,tl,tu).generationTime,
						  		 signalValue:Real=getValue(getMaxInAbsenseOfUndershoot(trace,ushPattern,tl,tu),ushPattern.signal).val
							  		}},
								  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
								  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_undershoots_2
									 }}						
					else			
						if --diagnostic pattern diagnostic pattern: the signal overshoots, instead of undershooting, showing the dual behavior
						(
							trace->exists(t|
							t.generationTime >tl and t.generationTime <=tu and 
							trace->forAll(t1|
							(t1.generationTime>=tl and t1.generationTime <=t.generationTime) implies
								getValue(t1,signal).val < targetVal and getValue(t1,signal).val > targetVal-maxVal.abs()
								)
								 and
								trace->forAll(t2| 
								(t2.generationTime > t.generationTime and t2.generationTime <=tu) implies									
								getValue(t2,signal).val >= targetVal  
								)

								)
							)
				
						then	
							Set{Tuple{vSignal:String=signal.id,
								 Records=Sequence{Tuple{
								 timestamp:Real=reportDualUndershoot(trace,ushPattern,tl,tu)->first().generationTime,
								 signalValue:Real=getValue(reportDualUndershoot(trace,ushPattern,tl,tu)->first(),signal).val
								  },
							Tuple{
							  		timestamp:Real=reportDualUndershoot(trace,ushPattern,tl,tu)->last().generationTime,
								 signalValue:Real=getValue(reportDualUndershoot(trace,ushPattern,tl,tu)->last(),signal).val
							  		}},
							  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
							  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_undershoots_4
							 }}	
							
						else  
							-- diagnostic pattern4: non-shown monotonicity constraint 
							if ushPattern.ouMonotonicity = sBTemPsy::MonotonicityType::MONOTONICITY then   
								if 
									trace->exists(t|
										t.generationTime > tl and t.generationTime <=tu and 
										getValue(t,signal).val < targetVal and getValue(t,signal).val > targetVal+maxVal and 
									trace->forAll(t2|
										(t2.generationTime >= tl and t2.generationTime <t.generationTime) implies 
										getValue(t2,signal).val > targetVal
										) 
										and 
										trace->forAll(t1|
										(t1.generationTime >= t.generationTime and t1.generationTime <=tu) implies 
										getValue(t1,signal).val > targetVal+maxVal
										) 
										and
											not(
												trace->forAll(t3| t3.generationTime >=tl and t3.generationTime < t.generationTime implies
													trace->forAll(t4| t4.generationTime> t3.generationTime and t4.generationTime <=t.generationTime implies
														getValue(t3,signal).val >= getValue(t4,signal).val	
													)
															 )
												)
										)
																	 
								then 				
											
										Set{Tuple{vSignal:String=signal.id,
											 Records=Sequence{Tuple{
											 timestamp:Real=reportMonotonicityViolationUndershoot(trace,ushPattern,tl,tu)->first().generationTime,
											 signalValue:Real=getValue(reportMonotonicityViolationUndershoot(trace,ushPattern,tl,tu)->first(),signal).val
											  },
										Tuple{
										  		 timestamp:Real=reportMonotonicityViolationUndershoot(trace,ushPattern,tl,tu)->last().generationTime,
											 signalValue:Real=getValue(reportMonotonicityViolationUndershoot(trace,ushPattern,tl,tu)->last(),signal).val
										  		}},
										  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
										  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_undershoots_3
												 }}
														
								else 
									Set{Tuple{vSignal:String=getPatternSignalName(ushPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
								endif
							else 
									Set{Tuple{vSignal:String=getPatternSignalName(ushPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
							endif 
						
						endif	 	
						
					endif
				endif
		
	endif		
		
-------------------
-- SPike Pattern --
-------------------		
													
-----------------------------------------------------------------------
-- Auxiliary functions for determining diagnostic information for spike
-----------------------------------------------------------------------
def: getMinInAbsenseOfSpike(trace:OrderedSet(trace::TraceElement),spike:sBTemPsy::Spike,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, min:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,min:trace::TraceElement) = Tuple{index:Integer=0 ,min:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime<=tu and getValue(elem,spike.signal).val < getValue(iter.min,spike.signal).val then 
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=iter.min}
	    endif
	) in result.min

def: getMaxInAbsenseOfSpike(trace:OrderedSet(trace::TraceElement),spike:sBTemPsy::Spike,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, max:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,max:trace::TraceElement) = Tuple{index:Integer=0 ,max:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime <=tu and getValue(elem,spike.signal).val > getValue(iter.max,spike.signal).val then 
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=iter.max}
	    endif
	) in result.max

def: reportPatternSpike(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,tl:Real,tu:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
if subtrace->isEmpty() then 
		Set{Tuple{vSignal:String='Empty trace',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}} -- if no records in the trace
else

	let 
	spkPattern:sBTemPsy::Spike=pattern.oclAsType(sBTemPsy::Spike),
	spkOcc:Integer=spkPattern.occSpk,  --fixed
	signal:sBTemPsy::Signal = spkPattern.signal, --signal name in the spike property
	spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature)=spkPattern.spkFeat, -- --, --{'a','w'} e.g.,{'a'->name,pred,'w'->name,pred} ; {a: name,pred}
	indAmp:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::a),
	indDur:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::w)
	in	
	-- diagnostic pattern: flat signal
	if noSpikeFlatSignal(subtrace,spkPattern,tl,tu) then
		-- Diagnostics information for diagnostic patterngo here								
		Set{Tuple{vSignal:String=signal.id,
		 Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},
		  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
		  	Tuple{leftBound:Real=tl, --getLeftBoundFlatSignal(subtrace,spkPattern,tl,tu).generationTime,
	  		  rightBound:Real= tu, --getRightBoundFlatSignal(subtrace,spkPattern,tl,tu).generationTime,
	  		  recordValue:Sequence(Real)=
	  		  Sequence{
					getValueOfBoundary(subtrace,signal,tl) --getValue(getLeftBoundFlatSignal(subtrace,spkPattern,tl,tu),signal).val
				 	}
		  	},
		  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_spike_3
			  }}											
	else 				
	-- diagnostic pattern : the signal decreases but does not show a spike 
		if noSpikeSignalDecreases(subtrace,spkPattern,tl,tu) then 
		-- Diagnostics information for diagnostic pattern  go here
			Set{Tuple{vSignal:String=signal.id,
				 Records=Sequence{Tuple{
				 timestamp:Real=getMaxInAbsenseOfSpike(subtrace,spkPattern,tl,tu).generationTime,--lastMaxSPKDec(subtrace,spkPattern,tl,tu).generationTime,
				 signalValue:Real=	getValue(getMaxInAbsenseOfSpike(subtrace,spkPattern,tl,tu),signal).val--getValue(lastMaxSPKDec(subtrace,spkPattern,tl,tu),signal).val
				  },
				Tuple{
		  		timestamp:Real=getMinInAbsenseOfSpike(subtrace,spkPattern,tl,tu).generationTime,--firstMinSPKDec(subtrace,spkPattern,tl,tu).generationTime,
		  		signalValue:Real=getValue(getMinInAbsenseOfSpike(subtrace,spkPattern,tl,tu),signal).val--getValue(firstMinSPKDec(subtrace,spkPattern,tl,tu),signal).val
		  		}},
				Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
				violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_spike_4
				 }}									
		else 
								-- diagnostic pattern : the signal increases but does not show a spike 
			if noSpikeSignalIncreases(subtrace,spkPattern,tl,tu)
			then 
				-- Diagnostics information for diagnostic pattern  go here
					Set{Tuple{vSignal:String=signal.id,
					 Records=Sequence{Tuple{
					 timestamp:Real=getMinInAbsenseOfSpike(subtrace,spkPattern,tl,tu).generationTime,--lastMinSPKInc(subtrace,spkPattern,tl,tu).generationTime,
					 signalValue:Real=getValue(getMinInAbsenseOfSpike(subtrace,spkPattern,tl,tu),signal).val--getValue(lastMinSPKInc(subtrace,spkPattern,tl,tu),signal).val
					  },
					Tuple{
			  		timestamp:Real=getMaxInAbsenseOfSpike(subtrace,spkPattern,tl,tu).generationTime,--firstMaxSPKInc(subtrace,spkPattern,tl,tu).generationTime,
			  		signalValue:Real=getValue(getMaxInAbsenseOfSpike(subtrace,spkPattern,tl,tu),signal).val--getValue(firstMaxSPKInc(subtrace,spkPattern,tl,tu),signal).val
			  		}},
					Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
					violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_spike_3
					}}
		
			else  			
				-- diagnostic pattern: spike violates amplitude condition
				if spikeFeaturesList.spkFName->includes(sBTemPsy::SpikeFeatureName::a) and allSpikesViolateAmplitude(subtrace,spkPattern,tl,tu,spikeFeaturesList,indAmp)=false 
				then 
					Set{Tuple{vSignal:String=signal.id,
				 		Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},
					  	Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
					  	Tuple{leftBound:Real=getSpikeAmpDiagInfos(subtrace,spkPattern,tl,tu,spikeFeaturesList,indAmp)->at(1),
					  		  rightBound:Real=getSpikeAmpDiagInfos(subtrace,spkPattern,tl,tu,spikeFeaturesList,indAmp)->at(2),
					  		  recordValue:Sequence(Real)=Sequence{getSpikeAmpDiagInfos(subtrace,spkPattern,tl,tu,spikeFeaturesList,indAmp)->at(3)}
					  	},
					  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_spike_1
						}}
				 else 					
					-- diagnostic pattern : spikes violate the width feature			
		 		 if spikeFeaturesList.spkFName->includes(sBTemPsy::SpikeFeatureName::w) and allSpikesViolateWidth(subtrace,spkPattern,tl,tu,spikeFeaturesList,indDur)=false
				 then 
		 						-- Diagnostics information for diagnostic pattern  go here
						Set{Tuple{vSignal:String=signal.id,
				 		Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},
					  	Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
					  	Tuple{leftBound:Real=getSpikeWidthDiagInfos(subtrace,spkPattern,tl,tu,spikeFeaturesList,indDur)->at(1),
			  		  rightBound:Real=getSpikeWidthDiagInfos(subtrace,spkPattern,tl,tu,spikeFeaturesList,indDur)->at(2),
			  		  recordValue:Sequence(Real)=Sequence{getSpikeWidthDiagInfos(subtrace,spkPattern,tl,tu,spikeFeaturesList,indDur)->at(3)}
					  	},
					  	violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_spike_2
						}}
			     else 	--not a valid violation
						Set{Tuple{vSignal:String=getPatternSignalName(spkPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType:diagnostics::ViolationType=diagnostics::ViolationType::NotSupported}}
					endif			
				endif	
			endif		
		endif
	endif		
endif

--------------------------
-- Oscillations Pattern --
--------------------------
-----------------------------------------------------------------------
-- Auxiliary functions for determining diagnostic information for spike
-----------------------------------------------------------------------
def: getMinInAbsenseOfOscillation(trace:OrderedSet(trace::TraceElement),oscillation:sBTemPsy::Oscillation,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, min:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,min:trace::TraceElement) = Tuple{index:Integer=0 ,min:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime<=tu and getValue(elem,oscillation.signal).val < getValue(iter.min,oscillation.signal).val then 
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, min:trace::TraceElement=iter.min}
	    endif
	) in result.min

def: getMaxInAbsenseOfOscillation(trace:OrderedSet(trace::TraceElement),oscillation:sBTemPsy::Oscillation,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, max:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,max:trace::TraceElement) = Tuple{index:Integer=0 ,max:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	 let currentIndex:Integer = iter.index + 1 in
	 if  elem.generationTime >= tl and elem.generationTime <=tu and getValue(elem,oscillation.signal).val > getValue(iter.max,oscillation.signal).val then 
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=elem}
	    else
	      Tuple{index:Integer = currentIndex, max:trace::TraceElement=iter.max}
	    endif
	) in result.max


def: reportPatternOscillations(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,tl:Real,tu:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if subtrace->isEmpty() then 
		 --if no records in the trace
			Set{Tuple{vSignal:String='Empty trace',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}} -- if no records in the trace
	else
	let 
		oscPattern:sBTemPsy::Oscillation=pattern.oclAsType(sBTemPsy::Oscillation),
		signal:sBTemPsy::Signal = oscPattern.signal, --signal name in the oscillations-based property
		oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature)=oscPattern.oscFeat, 
		indAmp:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::a),
		indP:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::w)
		in
			-- diagnostic pattern : flat signal
			if noOscFlatSignal(subtrace,oscPattern,tl,tu)
			 
			then
				Set{Tuple{vSignal:String=signal.id,
				 Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},
				  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
			  	   Tuple{leftBound:Real=tl,
		  		    rightBound:Real= tu, 
		  		  	recordValue:Sequence(Real)=Sequence{
					getValueOfBoundary(subtrace,signal,tl) 
			 				}
					  	},
					  	violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_oscillation_5
					 }}				
			else 
		--	 diagnostic pattern: the signal only decreases 
				if noOscSignalDecreases(subtrace,oscPattern,tl,tu)
				then
				
					Set{Tuple{vSignal:String=signal.id,
					 Records=Sequence{Tuple{
					timestamp:Real=getMaxInAbsenseOfOscillation(subtrace,oscPattern,tl,tu).generationTime,--lastMinSPKInc(subtrace,spkPattern,tl,tu).generationTime,
					signalValue:Real=getValue(getMaxInAbsenseOfOscillation(subtrace,oscPattern,tl,tu),signal).val--getValue(lastMinSPKInc(subtrace,spkPattern,tl,tu),signal).val
					  },
					Tuple{
			  		timestamp:Real=getMinInAbsenseOfOscillation(subtrace,oscPattern,tl,tu).generationTime,--lastMinSPKInc(subtrace,spkPattern,tl,tu).generationTime,
					signalValue:Real=getValue(getMinInAbsenseOfOscillation(subtrace,oscPattern,tl,tu),signal).val--getValue(lastMinSPKInc(subtrace,spkPattern,tl,tu),signal).val
			  		}},
					Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
					violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_oscillation_6
					}}
					
					
				else 
						-- diagnostic pattern: the signal only increases 
					if  noOscSignalIncreases(subtrace,oscPattern,tl,tu)
					then
					
						Set{Tuple{vSignal:String=signal.id,
						 Records=Sequence{Tuple{
						 timestamp:Real=getMinInAbsenseOfOscillation(subtrace,oscPattern,tl,tu).generationTime,
						 signalValue:Real=getValue(getMinInAbsenseOfOscillation(subtrace,oscPattern,tl,tu),signal).val
						  },
						Tuple{
				  		timestamp:Real=getMaxInAbsenseOfOscillation(subtrace,oscPattern,tl,tu).generationTime,
				  		signalValue:Real=getValue(getMaxInAbsenseOfOscillation(subtrace,oscPattern,tl,tu),signal).val
				  		}},
						Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
						violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_oscillation_7
						}}
					else 
				--	  diagnostic pattern: No oscillations: only one local extremum
					if noOscOneExtremum(subtrace,oscPattern,tl,tu)				
					then
							Set{Tuple{vSignal:String=signal.id,
							 Records=Sequence{Tuple{
							 timestamp:Real=getTheOnlySeenExtremumOsc(subtrace,oscPattern,tl,tu)->at(1),
							 signalValue:Real=getTheOnlySeenExtremumOsc(subtrace,oscPattern,tl,tu)->at(2)
							  }},
								 Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
								  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_oscillation_3
									}}
						else 
						-- diagnostic pattern : No oscillations: only two local extrema
						if noOscTwoExtrema(subtrace,oscPattern,tl,tu)					
						then							
							Set{Tuple{vSignal:String=signal.id,
							 Records=Sequence{Tuple{
							 timestamp:Real=getTheTwoSeenExtremaOsc(subtrace,oscPattern,tl,tu)->at(1),
							 signalValue:Real=getTheTwoSeenExtremaOsc(subtrace,oscPattern,tl,tu)->at(2)
							  },
							Tuple{
					  		timestamp:Real=getTheTwoSeenExtremaOsc(subtrace,oscPattern,tl,tu)->at(3),
					  		signalValue:Real=getTheTwoSeenExtremaOsc(subtrace,oscPattern,tl,tu)->at(4)
					  		}},
							Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,
							violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_oscillation_4
							}} 
						else 
								-- diagnostic pattern : oscillations violate the p2pAmp feature			
							 if oscFeaturesList.oscFName->includes(sBTemPsy::OscillationsFeatureName::a) and oscillationsWithP2pViolation(subtrace,oscPattern,tl,tu,oscFeaturesList,indAmp)=false then 
								Set{Tuple{vSignal:String=signal.id,
							 		Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},
								  	Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
								  	Tuple{leftBound:Real=p2pDiagnosticInformation(subtrace,oscPattern,tl,tu,oscFeaturesList,indAmp)->at(1),
								  		  rightBound:Real=p2pDiagnosticInformation(subtrace,oscPattern,tl,tu,oscFeaturesList,indAmp)->at(2),
								  		  recordValue:Sequence(Real)=Sequence{p2pDiagnosticInformation(subtrace,oscPattern,tl,tu,oscFeaturesList,indAmp)->at(3)}
								  	},
								  violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_oscillation_1
									}}
					     	else 
									-- diagnostic pattern : oscillations violate the period feature		
									if oscFeaturesList.oscFName->includes(sBTemPsy::OscillationsFeatureName::w) and oscillationsWithPeriodViolation(subtrace,oscPattern,tl,tu,oscFeaturesList,indP)=false then 							
										Set{Tuple{vSignal:String=signal.id,
								 		Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},
									  	Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
									  	Tuple{leftBound:Real=periodDiagnosticInformation(subtrace,oscPattern,tl,tu,oscFeaturesList,indP)->at(1),
								  		  rightBound:Real=periodDiagnosticInformation(subtrace,oscPattern,tl,tu,oscFeaturesList,indP)->at(2),
								  		  recordValue:Sequence(Real)=Sequence{periodDiagnosticInformation(subtrace,oscPattern,tl,tu,oscFeaturesList,indP)->at(3)}
								  		},
										violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_oscillation_2
										}}
									else 	
										--						not a valid violation
										Set{Tuple{vSignal:String=getPatternSignalName(oscPattern),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}} 							  
									endif	  
							  endif	
						  endif	  
					  endif	 
				  endif		 	 
			  endif					
	      endif					 				 
	endif					 				
		
		
---------------------------------------------------------

-- report diagnostics information for all single patterns
---------------------------------------------------------

def: reportSinglePattern(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, firsttime:Real, lasttime:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if pattern.oclIsTypeOf(sBTemPsy::EventAssertion) or pattern.oclIsTypeOf(sBTemPsy::StateAssertion)  then
			reportPatternDataAssertion(trace, pattern,firsttime,lasttime)
	else 
		if pattern.oclIsTypeOf(sBTemPsy::Rise) then
			reportPatternRiseTime(trace, pattern,firsttime,lasttime)
		else
			if pattern.oclIsTypeOf(sBTemPsy::Fall) then
			reportPatternFallTime(trace, pattern,firsttime,lasttime)
			else 
				if  pattern.oclIsTypeOf(sBTemPsy::Overshoot) then
						reportPatternOvershoot(trace, pattern,firsttime,lasttime) 
				else
					if pattern.oclIsTypeOf(sBTemPsy::Undershoot) then 
					 reportPatternUndershoot(trace, pattern,firsttime,lasttime)		
					 else 
					 
					 if pattern.oclIsTypeOf(sBTemPsy::Spike) then
					 	  reportPatternSpike(trace, pattern,firsttime,lasttime)		
					 else 	
					 	if pattern.oclIsTypeOf(sBTemPsy::Oscillation) then
					 	  reportPatternOscillations(trace, pattern,firsttime,lasttime)		
					 	else 
					 			null	
					 		endif	
					 	endif	
  					endif
				 endif
			endif
		endif
	endif


			 			
-------------------
-- Order Pattern --
-------------------				 			
def: reportPatternOrderRelationship(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,tl:Real,tu:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if subtrace->isEmpty() then 
		Set{Tuple{vSignal:String='Empty trace',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}} -- if no records in the trace
	else
		let 
		orderPattern:sBTemPsy::Order=pattern.oclAsType(sBTemPsy::Order),
		causePattern:sBTemPsy::Pattern=orderPattern.cause,
		causeEffectDistance:sBTemPsy::TimeDistance=orderPattern.causeEffectDistance,
		causeEffectDistanceCompOp:sBTemPsy::ComparingOperator=orderPattern.causeEffectDistance.comparingOperator,
		causeEffectDistanceBoundary:Real=orderPattern.causeEffectDistance.boundary.val,
		effectPatternsList:OrderedSet(sBTemPsy::Pattern)=orderPattern.effect.effectsPList
		
	in
		-- dp_if/then1: cause pattern holds, but effect pattern does not; NSEP violation type				
				if 	
					subtrace->exists(t1,t2| t1.generationTime >=tl and
					t1.generationTime < t2.generationTime and t2.generationTime < tu and checkSinglePattern(subtrace,causePattern,t1.generationTime,t2.generationTime) = true and
						subtrace->forAll(t3,t4| (t3.generationTime > t2.generationTime and t3.generationTime < t4.generationTime and t4.generationTime <=tu) implies
						 		effectPatternsList->forAll(p|
										checkSinglePattern(subtrace,p,t3.generationTime,t4.generationTime)=false 
									)
								)
						)	
	
				then 
					-- diagnostics information for i_dp_if/then1 go here
					Set{Tuple{vSignal:String=getCauseSignalName(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},
						Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
						Tuple{leftBound:Real=getLastCauseRecordNSEP(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),tl,tu).generationTime,rightBound:Real=tu,recordalue:Sequence(Real)=Sequence{}},
						 violationType=diagnostics::ViolationType::i_dp_if_then_1
						}}
				else			
					if causeEffectDistance <> null then 
					-- dp_if/then2: if a then b; the effect pattern b does not hold within the time distance between t2 and t3; Not satisfied time constraint over time distance between cause and effect patterns; wrong temporal order
							if 
								subtrace->exists(t1,t2| t1.generationTime >=tl and
											t1.generationTime < t2.generationTime and t2.generationTime <tu and checkSinglePattern(subtrace,causePattern,t1.generationTime,t2.generationTime)=true and
								subtrace->forAll(t3,t4| (t3.generationTime >=t2.generationTime and t3.generationTime < t4.generationTime and t4.generationTime <=tu) implies
								 (checkSinglePattern(subtrace,causePattern,t3.generationTime,t4.generationTime)	implies
								 			(			
												( causeEffectDistanceCompOp  = sBTemPsy::ComparingOperator::ATMOST and  t3.generationTime-t2.generationTime > causeEffectDistanceBoundary) or
												( causeEffectDistanceCompOp  = sBTemPsy::ComparingOperator::ATLEAST and  t3.generationTime-t2.generationTime < causeEffectDistanceBoundary) or
												( causeEffectDistanceCompOp  = sBTemPsy::ComparingOperator::EXACTLY and  t3.generationTime-t2.generationTime <> causeEffectDistanceBoundary) 
											)
								 		)
												)
											)
							then  
								Set{Tuple{vSignal:String=getCauseSignalName(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).concat('/').concat(getEffectSignalName(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu)),
									 Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},
									  Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
									  	Tuple{leftBound:Real=getLastCauseRecordTimestamp(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).generationTime,
									  		  rightBound:Real=getFirstEffectRecordTimestamp(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).generationTime,
									  		  recordValue:Sequence(Real)= Sequence{getOrderTimeDistance(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary, effectPatternsList, tl,tu)}
									  	},
									  	violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_if_then_2
									 }}
							else  
								Set{Tuple{vSignal:String=getCauseSignalName(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu).concat('/').concat(getEffectSignalName(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu)),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}} 
							endif			 				 												
						else  
								Set{Tuple{vSignal:String=getCauseSignalName(subtrace,causePattern,getEffect(subtrace,causePattern,effectPatternsList,tl,tu),causeEffectDistanceCompOp,causeEffectDistanceBoundary,tl,tu),Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}} 
							endif	
						endif						 				 
					endif

def: reportPattern(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern, firsttime:Real, lasttime:Real):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if pattern.oclIsTypeOf(sBTemPsy::Order) then
		reportPatternOrderRelationship(trace, pattern,firsttime,lasttime)
	else
		reportSinglePattern(trace, pattern,firsttime,lasttime)
	endif
		
-------- ******************------
-------- SCOPES
-------- ******************------	
-----------------------------------------
-- auxiliary function for "before" scope
-----------------------------------------
def: getBeforeEventBoundary(trace:OrderedSet(trace::TraceElement),evBoundary:sBTemPsy::Pattern,tl:Real,tu:Real):Real=
	trace -> select(t|
	trace -> exists(t1,t2| t1.generationTime > tl  and t1.generationTime < t2.generationTime and t2.generationTime <= tu
		and checkPattern(trace, evBoundary, t1.generationTime, t2.generationTime) 
--		and trace -> exists(t3,t4| t3.generationTime >=tl and t3.generationTime < t4.generationTime and t4.generationTime <= t1.generationTime and 
--			checkPattern(trace, pattern, t3.generationTime, t4.generationTime)=false 
--							)	
		and t1.generationTime=t.generationTime
					)
			)->first().generationTime

-----------------------------------------
-- auxiliary function for "after" scope
-----------------------------------------
def: getAfterEventBoundary(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,evBoundary:sBTemPsy::Pattern,tl:Real,tu:Real):Real=
	trace -> select(t|
	trace -> exists(t1,t2| t1.generationTime > tl  and t1.generationTime < t2.generationTime and t2.generationTime <= tu
		and checkPattern(trace, evBoundary, t1.generationTime, t2.generationTime) 
--		and trace -> exists(t3,t4| t3.generationTime >=tl and t3.generationTime < t4.generationTime and t4.generationTime <= t1.generationTime and 
--			checkPattern(trace, pattern, t3.generationTime, t4.generationTime)=false 
--							)	
		and t2.generationTime=t.generationTime
					)
	)->first().generationTime

-----------------------------------------------
-- auxiliary function for "between-and" scope--
----------------------------------------------- 
def: getBetweenLeftEventBoundary(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,evBoundary1:sBTemPsy::Pattern,evBoundary2:sBTemPsy::Pattern,tl:Real,tu:Real):Real=
	trace -> select(t|
	trace -> exists(t1,t2 | t1.generationTime >= tl and t1.generationTime < t2.generationTime and t2.generationTime < tu and 
		checkPattern(trace, evBoundary1, t1.generationTime, t2.generationTime)=true  and
		trace -> exists(t3,t4 | t3.generationTime > t2.generationTime and t3.generationTime < t4.generationTime and t4.generationTime <= tu and 
		checkPattern(trace, evBoundary2, t3.generationTime, t4.generationTime)=true
--		  and
--		checkPattern(trace, pattern, t2.generationTime, t3.generationTime)=false
					)   			
		and t.generationTime=t2.generationTime
			)
		)->first().generationTime

def: getBetweenRightEventBoundary(trace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Pattern,evBoundary1:sBTemPsy::Pattern,evBoundary2:sBTemPsy::Pattern,tl:Real,tu:Real):Real=
	trace -> select(t|
--		trace -> exists(t1,t2 | t1.generationTime >= tl and t1.generationTime < t2.generationTime and t2.generationTime < tu and 
--			checkPattern(trace, evBoundary1, t1.generationTime, t2.generationTime)=true and
			trace -> exists(t3,t4 | t3.generationTime > getBetweenLeftEventBoundary(trace,pattern,evBoundary1,evBoundary2,tl,tu) and t3.generationTime < t4.generationTime and t4.generationTime <= tu and 
			checkPattern(trace, evBoundary2, t3.generationTime, t4.generationTime)=true 
--			and
--			checkPattern(trace, pattern, t2.generationTime, t3.generationTime)=false   			
			and t.generationTime=t3.generationTime			
						   )
				--  ) 
			)->first().generationTime

-------------------------------------------------------
--Scopes: Diagnostics Patterns and Violation Details --
-------------------------------------------------------
-- When a scope boundary does not even within the trace, the violation to report is only related to that boundary. 
-- As the pattern has not been checker yet, there is no concrete data about the signal name to report. 
-- For this reason, whenever the scope is violated, the tool does not report a signal name. It returns ' instead.

def: globally(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	let tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime in 
		reportPattern(trace, property.pattern, tl, tu)

def: at(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	let punctualScope:sBTemPsy::PunctualScope=property.scope.oclAsType(sBTemPsy::PunctualScope), 
		tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime,
		atValue:Real=punctualScope.absolute.absoluteB.val
	in  
	if (atValue < tl or atValue > tu) then
		Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=Tuple{leftBound:Real=tl,rightBound:Real=tu, recordValue:Sequence(Real)=Sequence{atValue}},violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_a_at_1}} 
	else 
		reportPattern(trace, property.pattern, atValue, atValue)
		endif
------------------------------------------------
-- Main and auxiliary functions for Before scope
------------------------------------------------
def: getBeforeFirstTimestampOfEventBoundarySat(trace:OrderedSet(trace::TraceElement), tl:Real, tu:Real, evBoundary:sBTemPsy::Pattern, pattern:sBTemPsy::Pattern):Real=
	trace->select( t| 
	 trace->exists(t1,t2|
	 t1.generationTime > tl and t1.generationTime < t2.generationTime and t2.generationTime <= tu and 
		checkPattern(trace, evBoundary, t1.generationTime, t2.generationTime)=true
		and t.generationTime = t1.generationTime
		and trace->forAll( t3,t4| t3.generationTime >=tl and t3.generationTime < t4.generationTime and 
			t4.generationTime < t1.generationTime implies
			checkPattern(trace,pattern,t3.generationTime,t4.generationTime)=false			
			)
		) 
	)->first().generationTime


def: getBeforeLastTimestampOfEventBoundarySat(trace:OrderedSet(trace::TraceElement), tl:Real, tu:Real, evBoundary:sBTemPsy::Pattern, pattern:sBTemPsy::Pattern):Real=
	trace->select(t| 
		trace->exists(t1,t2|
			t1.generationTime > tl and t1.generationTime < t2.generationTime and t2.generationTime <= tu and 
			checkPattern(trace, evBoundary, t1.generationTime, t2.generationTime)=true
			and t.generationTime > getBeforeFirstTimestampOfEventBoundarySat(trace,tl,tu,evBoundary,pattern) and 
			t.generationTime = t2.generationTime
		) 
	)->first().generationTime
			
def: before(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	let tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime, 
		beforeScope:sBTemPsy::Before=property.scope.oclAsType(sBTemPsy::Before),
		simplePattern:sBTemPsy::SimplePattern=property.pattern.oclAsType(sBTemPsy::SimplePattern)		
	in 
	if  (beforeScope.boundary.absoluteB <> null) then
		let absBoundary:Real=beforeScope.boundary.absoluteB.val in 
		-- diagnostics pattern bef1:    or  > 
		if (absBoundary <=tl or absBoundary > tu) then --dp_a_bef1
			Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=Tuple{leftBound:Real=tl,rightBound:Real=tu, recordValue:Sequence(Real)=Sequence{absBoundary}},violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_a_bef_1}} 
		else
			reportPattern(trace, property.pattern, tl, absBoundary)
		endif		
	else	
		if (beforeScope.boundary.eventB <> null) then 
	 		let evBoundary:sBTemPsy::Pattern=beforeScope.boundary.eventB in  		 		
	 		if -- diagnostic pattern dp_e_bef_1
	 			trace -> exists(t1,t2| t1.generationTime > tl  and t1.generationTime < t2.generationTime and t2.generationTime <= tu
 				 and checkPattern(trace, evBoundary, t1.generationTime, t2.generationTime) 
				 and trace -> forAll(t3,t4| t3.generationTime >=tl and t3.generationTime < t4.generationTime and t4.generationTime < t1.generationTime implies 
 				 checkPattern(trace, property.pattern, t3.generationTime, t4.generationTime)=false 
								)	
					)								 		
		 		then 	--violation information of scope ; idp_e_bef2	 getFirstTimestampOfEventBoundarySat(trace,tl,tu,evBoundary) 	 		
		 			Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{}, Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=Tuple{leftBound:Real=getBeforeFirstTimestampOfEventBoundarySat(trace,tl,tu,evBoundary,property.pattern),rightBound:Real=getBeforeLastTimestampOfEventBoundarySat(trace,tl,tu,evBoundary,property.pattern), recordValue:Sequence(Real)=Sequence{}},violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_e_bef_1}}   
		 		else 	
		 			if trace -> exists(t1,t2| t1.generationTime > tl  and t1.generationTime < t2.generationTime and t2.generationTime <= tu
		 				 and checkPattern(trace, evBoundary, t1.generationTime, t2.generationTime) 
									)	
					then 		
		 				reportPattern(trace, property.pattern, tl, getBeforeEventBoundary(trace,evBoundary,tl,tu))	 
		 			else
		 				invalid -- invalid means that either 1) there is no trace portion delimited by the scope over which the diagnostic pattern shall be checked or 2) none of the diagnostic patterns is satisfied
		 			endif		 				
		 		endif			
			else
				invalid
			endif	
	 endif	
	 
-----------------------------------------------
-- Main and auxiliary functions for After scope
-----------------------------------------------
def: getAfterFirstTimestampOfEventBoundarySat(trace:OrderedSet(trace::TraceElement), tl:Real, tu:Real, evBoundary:sBTemPsy::Pattern,pattern:sBTemPsy::Pattern):Real=
	trace->select( t| 
		trace->exists(t1,t2|
		t1.generationTime >= tl and t1.generationTime < t2.generationTime and t2.generationTime < tu and 
		checkPattern(trace, evBoundary, t1.generationTime, t2.generationTime)=true
		and trace->forAll(t3,t4| t3.generationTime >t2.generationTime and t3.generationTime < t4.generationTime and 
			t4.generationTime <= tu implies
			checkPattern(trace,pattern,t3.generationTime,t4.generationTime)=false			
			)	
		and t.generationTime = t1.generationTime
		) 
	)->first().generationTime

def: getAfterLastTimestampOfEventBoundarySat(trace:OrderedSet(trace::TraceElement), tl:Real, tu:Real, evBoundary:sBTemPsy::Pattern,pattern:sBTemPsy::Pattern):Real=
	trace->select( t| 
		trace->exists(t1,t2|
		t1.generationTime >= tl and t1.generationTime < t2.generationTime and t2.generationTime < tu and 
			checkPattern(trace, evBoundary, t1.generationTime, t2.generationTime)=true
			and t.generationTime > getAfterFirstTimestampOfEventBoundarySat(trace,tl,tu,evBoundary,pattern)  
			and t.generationTime = t2.generationTime
			) 
			)->first().generationTime

def: after(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	let tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime, 
		afterScope:sBTemPsy::After=property.scope.oclAsType(sBTemPsy::After),
		simplePattern:sBTemPsy::SimplePattern=property.pattern.oclAsType(sBTemPsy::SimplePattern)
	in 
	if  (afterScope.boundary.absoluteB <> null) then
		-- diagnostics pattern aft1:  <  or   
			let absBoundary:Real=afterScope.boundary.absoluteB.val in 
			if (afterScope.boundary.absoluteB.val <tl or afterScope.boundary.absoluteB.val >= tu) then 
				Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=Tuple{leftBound:Real=tl,rightBound:Real=tu, recordValue:Sequence(Real)=Sequence{absBoundary}},violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_a_aft_1}} 
			else
				---- diagnostics pattern aft2: (,] (v):  , [, ] |= 
				reportPattern(trace, property.pattern, afterScope.boundary.absoluteB.val, tu)
			endif	
	else	
		if (afterScope.boundary.eventB <> null) then 
			let evBoundary:sBTemPsy::Pattern=afterScope.boundary.eventB in  		 					
	 		if -- diagnsotic pattern dp_e_aft_1
	 			trace -> exists(t1,t2| t1.generationTime >= tl  and t1.generationTime < t2.generationTime and t2.generationTime < tu
 				and checkPattern(trace, afterScope.boundary.eventB, t1.generationTime, t2.generationTime) 
				and trace -> forAll(t3,t4| t3.generationTime >t2.generationTime and t3.generationTime < t4.generationTime and t4.generationTime <= tu implies
				 checkPattern(trace, property.pattern, t3.generationTime, t4.generationTime) = false 
								)	
				)									 		
	 		then 
	 			Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{}, Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=Tuple{leftBound:Real=getAfterFirstTimestampOfEventBoundarySat(trace,tl,tu,evBoundary,property.pattern),rightBound:Real=getAfterLastTimestampOfEventBoundarySat(trace,tl,tu,evBoundary,property.pattern), recordValue:Sequence(Real)=Sequence{}},violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_e_aft_1}}   			
	 		else 
	 			if --scope is satisfied
	 			trace -> exists(t1,t2| t1.generationTime >= tl  and t1.generationTime < t2.generationTime and t2.generationTime < tu
 				and checkPattern(trace, afterScope.boundary.eventB, t1.generationTime, t2.generationTime) 
								)
				then 	-- report violation in the trace portion delimited by the scope				
					reportPattern(trace, property.pattern, getAfterEventBoundary(trace,property.pattern,afterScope.boundary.eventB,tl,tu),tu)	
	 			else
					invalid -- invalid means that either 1) there is no trace portion delimited by the scope over which the diagnostic pattern shall be checked or 2) none of the diagnostic patterns is satisfied  
				endif			
	 		endif		 		
		else
			invalid
		endif	
	 endif		 		
	
----------------------------------------------------
-- Main and auxiliary functions for BetweenAnd scope
----------------------------------------------------	
		
def: betweenand(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
 	let betweenAndScope:sBTemPsy::BetweenAnd=property.scope.oclAsType(sBTemPsy::BetweenAnd),
 		simplePattern:sBTemPsy::SimplePattern=property.pattern.oclAsType(sBTemPsy::SimplePattern),  	
		tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime in 		
	if (betweenAndScope.boundary1.absoluteB <> null and betweenAndScope.boundary2.absoluteB <> null) then
		-- diagnostics pattern bet1:  < or > tu or n>= m
		let absBoundary1:Real=betweenAndScope.boundary1.absoluteB.val,
			absBoundary2:Real=betweenAndScope.boundary2.absoluteB.val
		 in 
		if (absBoundary1 < tl or absBoundary1 >= absBoundary2 or absBoundary2 > tu ) then 
			Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=Tuple{leftBound:Real=tl,rightBound:Real=tu, recordValue:Sequence(Real)=Sequence{absBoundary1}->append(absBoundary2)},violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_a_bet_1}} 
		else
			---- diagnostics pattern bet2: (,] (v):  , [, ] |= 
			reportPattern(trace, property.pattern, betweenAndScope.boundary1.absoluteB.val, betweenAndScope.boundary2.absoluteB.val)
		endif									 
	else 	
	if betweenAndScope.boundary1.eventB <> null and betweenAndScope.boundary2.eventB <> null then 
		if	( 
			 trace -> exists(t1,t2 | 
			 t1.generationTime >= tl and t1.generationTime < t2.generationTime and
			 trace->exists(t3,t4|
			 t2.generationTime < t3.generationTime and t3.generationTime < t4.generationTime and t4.generationTime <=tu and
			checkPattern(trace, betweenAndScope.boundary1.eventB, t1.generationTime, t2.generationTime) and
			checkPattern(trace, betweenAndScope.boundary2.eventB, t3.generationTime, t4.generationTime) and
			checkPattern(trace, property.pattern, t2.generationTime, t3.generationTime)=false
							)   
						)					
			)
		then		
			Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=Tuple{leftBound:Real=getBetweenLeftEventBoundary(trace,property.pattern,betweenAndScope.boundary1.eventB,betweenAndScope.boundary2.eventB,tl,tu),rightBound:Real=getBetweenRightEventBoundary(trace,property.pattern,betweenAndScope.boundary1.eventB,betweenAndScope.boundary2.eventB,tl,tu),recordValue:Sequence(Real)=Sequence{}},violationType:diagnostics::ViolationType=diagnostics::ViolationType::i_dp_e_bet_1}} 
		else 		
				if ( --scope is satisfied
				 trace -> exists(t1,t2 | 
				 t1.generationTime >= tl and t1.generationTime < t2.generationTime and
				 trace->exists(t3,t4|
				 t2.generationTime < t3.generationTime and t3.generationTime < t4.generationTime and t4.generationTime <=tu and
				checkPattern(trace, betweenAndScope.boundary1.eventB, t1.generationTime, t2.generationTime) and
				checkPattern(trace, betweenAndScope.boundary2.eventB, t3.generationTime, t4.generationTime) 
								)   
						)					
					)
				then -- report violation in the trace portion delimited by the scope
					reportPattern(trace, property.pattern, getBetweenLeftEventBoundary(trace,property.pattern,betweenAndScope.boundary1.eventB,betweenAndScope.boundary2.eventB,tl,tu),getBetweenRightEventBoundary(trace,property.pattern,betweenAndScope.boundary1.eventB,betweenAndScope.boundary2.eventB,tl,tu))	
				else
					invalid -- invalid means that either 1) there is no trace portion delimited by the scope over which the diagnostic pattern shall be checked or 2) none of the diagnostic patterns is satisfied  
				endif
			endif	
	else
		invalid
	endif
endif						

------ ******************------
------ Main function
------ ******************------	
def: reportSimpleProperty(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if property.scope.oclIsTypeOf(sBTemPsy::Globally) then
		globally(trace,property)
	else
		if property.scope.oclIsTypeOf(sBTemPsy::PunctualScope) then 
			at(trace,property)
		else
			if property.scope.oclIsTypeOf(sBTemPsy::Before) then 
				before(trace,property) 
			else
				if property.scope.oclIsTypeOf(sBTemPsy::After) then 
					after(trace,property)  
				else 
					if property.scope.oclIsTypeOf(sBTemPsy::BetweenAnd) then 
						betweenand(trace,property)  
					else 
						null 
					endif
				endif
			endif			
		endif	
	endif
		

------ ******************------
------ SCOPES for Checker
------ ******************------	
def: globallyCheck(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property): Boolean=
	let tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime in 
	checkPattern(trace, property.pattern, tl, tu)
	
	
def: beforeCheck(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property): Boolean=
	let tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime, 
		beforeScope:sBTemPsy::Before=property.scope.oclAsType(sBTemPsy::Before) in 
	
	if  (beforeScope.boundary.absoluteB <> null) then
		tl <= beforeScope.boundary.absoluteB.val and beforeScope.boundary.absoluteB.val <= tu and
		checkPattern(trace, property.pattern, tl, beforeScope.boundary.absoluteB.val)
	else
		if beforeScope.boundary.eventB <> null then 
	 		(
	 			trace -> forAll(t1| tl < t1.generationTime  and t1.generationTime <tu
	 				and trace -> forAll(t2|	
		 				( t1.generationTime <t2.generationTime and 
		 							t2.generationTime <= tu and
									checkPattern(trace, beforeScope.boundary.eventB, t1.generationTime, t2.generationTime) 
						) 
						implies 
						(	trace -> exists(t3| tl <=t3.generationTime and t3.generationTime<=t1.generationTime and
								trace -> exists(t4| t3.generationTime < t4.generationTime and t4.generationTime <=t1.generationTime and 	
									checkPattern(trace, property.pattern, t3.generationTime, t4.generationTime))
							)	
						)
					)
				)	
	 		)
	 		else
	 			false
	 		endif
		
	endif	

def: atCheck(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property):Boolean=
	(	let punctualScope:sBTemPsy::PunctualScope=property.scope.oclAsType(sBTemPsy::PunctualScope), 
			tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime in 
		
		tl <= punctualScope.absolute.absoluteB.val and punctualScope.absolute.absoluteB.val <= tu and
							checkPattern(trace, property.pattern, punctualScope.absolute.absoluteB.val,punctualScope.absolute.absoluteB.val)
	)

	
		
def: afterCheck(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property):Boolean=
	let tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime, 
	 	afterScope:sBTemPsy::After=property.scope.oclAsType(sBTemPsy::After) in 	
	if  (afterScope.boundary.absoluteB <> null) then 
			(
				tl <= afterScope.boundary.absoluteB.val and afterScope.boundary.absoluteB.val <= tu and
				checkPattern(trace, property.pattern, afterScope.boundary.absoluteB.val,tu)												
			)
	else		
	(	
		if (afterScope.boundary.eventB <> null) then 
 		 (
 			trace -> forAll(t1 | tl <= t1.generationTime and t1.generationTime <= tu  and
 				trace -> forAll( t2|	
		 			(  t1.generationTime < t2.generationTime and t2.generationTime <= tu and 
									checkPattern(trace, afterScope.boundary.eventB, t1.generationTime, t2.generationTime) ) 
					implies 
					(	trace -> exists(t3 | t2.generationTime <=t3.generationTime and t3.generationTime <=tu and 
							trace -> exists(t4| 
								( 	t3.generationTime < t4.generationTime and t4.generationTime <=tu and 	
									checkPattern(trace, property.pattern, t3.generationTime, t4.generationTime)
								)
							)
						)	
					)
				)
			)	
 		)
 		else
 			false
 		endif
	)
	endif
					
		
def: betweenandCheck(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property):Boolean=
 	( 	let betweenAndScope:sBTemPsy::BetweenAnd=property.scope.oclAsType(sBTemPsy::BetweenAnd),  	
 			tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime in 
				
		if betweenAndScope.boundary1.absoluteB <> null then
			tl <= betweenAndScope.boundary1.absoluteB.val and betweenAndScope.boundary1.absoluteB.val<= betweenAndScope.boundary2.absoluteB.val and betweenAndScope.boundary2.absoluteB.val <= tu and
			checkPattern(trace, property.pattern, betweenAndScope.boundary1.absoluteB.val, betweenAndScope.boundary2.absoluteB.val)					 
		else 
		(
			if betweenAndScope.boundary1.eventB <> null and betweenAndScope.boundary2.eventB <> null then 
			(  
				trace -> forAll(t1 | tl <=t1.generationTime and t1.generationTime <=tu and
					trace -> forAll(t2 | t1.generationTime < t2.generationTime and t2.generationTime <=tu and
						trace ->forAll(t3 | t2.generationTime < t3.generationTime and t3.generationTime <=tu and
							trace ->forAll( t4 |t3.generationTime < t4.generationTime and t4.generationTime <=tu and
								(	checkPattern(trace, betweenAndScope.boundary1.eventB, t1.generationTime, t2.generationTime) and 
									checkPattern(trace, betweenAndScope.boundary2.eventB, t3.generationTime, t4.generationTime)
								) 
							implies
								checkPattern(trace, betweenAndScope.boundary2.eventB, t2.generationTime, t3.generationTime)
							)
						)
					)
				)
			)
			else
				false
			endif
		)
		endif			
			
	)

----------------------------------
-- check functions for recursion 
----------------------------------
----------- Recursion over properties -----------
def: checkSimpleProperty(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::Property): Boolean= 
	if property.scope.oclIsTypeOf(sBTemPsy::Globally) then
		globallyCheck(trace,property)
	else
		if property.scope.oclIsTypeOf(sBTemPsy::Before) then 
			beforeCheck(trace,property)
		else
			if property.scope.oclIsTypeOf(sBTemPsy::After) then  
				afterCheck(trace,property) 
			else
				if property.scope.oclIsTypeOf(sBTemPsy::BetweenAnd) then
					betweenandCheck(trace,property)
				else
					if property.scope.oclIsTypeOf(sBTemPsy::PunctualScope) then 
						atCheck(trace,property)
					 else
					 	true
					 endif
				endif
			endif
		endif
	endif

	
def: checkProperty(trace:OrderedSet(trace::TraceElement), property:sBTemPsy::AbstractProperty): Boolean=
( 
	if trace->isEmpty() then true -- if no records in the trace
	else
	if property.oclIsTypeOf(sBTemPsy::OrProperty) then  
			let orProperty:sBTemPsy::OrProperty = property.oclAsType(sBTemPsy::OrProperty), 
				orProOne:sBTemPsy::AbstractProperty = orProperty.property1,
				orProTwo:sBTemPsy::AbstractProperty = orProperty.property2
			in
			checkProperty(trace,orProOne) or 
			checkProperty(trace, orProTwo)
			
		else
			if property.oclIsTypeOf(sBTemPsy::AndProperty) then  
				let andProperty:sBTemPsy::AndProperty = property.oclAsType(sBTemPsy::AndProperty), 
				andProOne:sBTemPsy::AbstractProperty = andProperty.property1,
				andProTwo:sBTemPsy::AbstractProperty = andProperty.property2
			in
			checkProperty(trace,andProOne) and 
			checkProperty(trace, andProTwo)		 	
			
		else  
				-- negation	
				if property.oclIsTypeOf(sBTemPsy::NotProperty) then 
					let negProp:sBTemPsy::NotProperty = property.oclAsType(sBTemPsy::NotProperty) in 
						checkProperty(trace,negProp.property)=false					
				else -- one simple property case
		let simpleProperty:sBTemPsy::Property=property.oclAsType(sBTemPsy::Property) in
			checkSimpleProperty(trace,simpleProperty)
			

	endif
	endif
	endif
	endif
	
)		

------------------------------------
-- Auxiliary functions for negation 
------------------------------------

def: reportStateInNegation(trace:OrderedSet(trace::TraceElement),stateAssertion:sBTemPsy::StateAssertion,tl:Real,tu:Real):trace::TraceElement=
	-- target: takes 1 if signal satisfies the predicate, 0 otherwise
	let result:Tuple(index:Integer, target:Integer, traceElement:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElement:trace::TraceElement) = Tuple{index:Integer=0 , target:Integer=0, traceElement:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  then 
	      if iter.target=0 and reportStateViolatedPredicate(elem,stateAssertion)=true  then
	      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElement:trace::TraceElement=elem}
	      else
		      	if iter.target=0 and reportStateSatisfiedPredicate(elem,stateAssertion)=true then
	  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1, traceElement:trace::TraceElement=elem} 
		      	else
		      		iter
		      endif
		  endif    
	else
			iter
	endif	      	 		     
) in result.traceElement
	

def: getTimestampsOfSatSpikeInNegation(trace:OrderedSet(trace::TraceElement),spkPattern:sBTemPsy::Spike,tl:Real,tu:Real):trace::TraceElement=
	let spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature)=spkPattern.spkFeat, -- --, --{'a','w','sp1','sp2'} e.g.,{'a'->name,pred,'w'->name,pred} ; {a: name,pred}
	indAmp:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::a),
	indDur:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::w),
	signal:sBTemPsy::Signal=spkPattern.signal
	in
	trace->select(t| 
			trace->exists(t1,t2| 
				trace->exists(t3,t4| 
					 trace->exists(t5 | 
						tl<= t1.generationTime and t1.generationTime < t2.generationTime and t2.generationTime< t3.generationTime and t3.generationTime < t4.generationTime
					 	and t4.generationTime< t5.generationTime and t5.generationTime <=tu
						and (
								(	isMinimum(trace, t2, t1.generationTime, t3.generationTime, signal) 	-- consider the first local minimum (t1)
				 					and isLocalMaximum(trace, t3, t2.generationTime, t4.generationTime, signal)	-- consider the first local maximum  (t2)
				 					and isMinimum(trace, t4, t3.generationTime,t5.generationTime,signal)	-- consider the second local minimum (t3)		
								)
								or -- consider the first local maximum (t1), local minimum (t2) and second local maximum (t3)
								(	isMaximum(trace, t2, t1.generationTime, t3.generationTime, signal) 	-- consider the first local minimum (t1)
				 					and isLocalMinimum(trace, t3, t2.generationTime, t4.generationTime, signal)	-- consider the first local maximum  (t2)
				 					and isMaximum(trace, t4, t3.generationTime,t5.generationTime,signal)								
				 				)
							) 
							and				-- constraining over amplitude feature -- 
							spikeAmplitude(getValue(t2,signal).val,getValue(t3,signal).val,getValue(t4,signal).val,spikeFeaturesList,indAmp)
							and
							spikeWidth(t1.generationTime,t3.generationTime,spikeFeaturesList,indDur) 
					)
				)
			and t.generationTime=t1.generationTime)
	)->first()
	

def: getLastTimestampOfSatSpikeInNegation(trace:OrderedSet(trace::TraceElement),spkPattern:sBTemPsy::Spike,tl:Real,tu:Real):trace::TraceElement=
	let spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature)=spkPattern.spkFeat, -- --, --{'a','w','sp1','sp2'} e.g.,{'a'->name,pred,'w'->name,pred} ; {a: name,pred}
	indAmp:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::a),
	indDur:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::w),
	signal:sBTemPsy::Signal=spkPattern.signal
	in
	trace->select(t| 
			trace->exists(t1,t2| 
				trace->exists(t3,t4| 
					 trace->exists(t5 | 
						tl<= t1.generationTime and t1.generationTime < t2.generationTime and t2.generationTime< t3.generationTime and t3.generationTime < t4.generationTime
					 	and t4.generationTime< t5.generationTime and t5.generationTime <=tu
						and (
								(	isMinimum(trace, t2, t1.generationTime, t3.generationTime, signal) 	-- consider the first local minimum (t1)
				 					and isLocalMaximum(trace, t3, t2.generationTime, t4.generationTime, signal)	-- consider the first local maximum  (t2)
				 					and isMinimum(trace, t4, t3.generationTime,t5.generationTime,signal)	-- consider the second local minimum (t3)		
								)
								or -- consider the first local maximum (t1), local minimum (t2) and second local maximum (t3)
								(	isMaximum(trace, t2, t1.generationTime, t3.generationTime, signal) 	-- consider the first local minimum (t1)
				 					and isLocalMinimum(trace, t3, t2.generationTime, t4.generationTime, signal)	-- consider the first local maximum  (t2)
				 					and isMaximum(trace, t4, t3.generationTime,t5.generationTime,signal)								
				 				)
							) 
							and				-- constraining over amplitude feature -- 
							spikeAmplitude(getValue(t2,signal).val,getValue(t3,signal).val,getValue(t4,signal).val,spikeFeaturesList,indAmp)
							and
							spikeWidth(t1.generationTime,t3.generationTime,spikeFeaturesList,indDur) 
				and t.generationTime=t5.generationTime	and t.generationTime > getLastTimestampOfSatSpikeInNegation(trace,spkPattern,tl,tu).generationTime)
				)
			)
	)->first()	
	






--
--def: getFirstTimestampOfSatOscillationInNegation(trace:OrderedSet(trace::TraceElement),oscPattern:sBTemPsy::Oscillation,tl:Real,tu:Real):trace::TraceElement=
--	let 
--	signal:sBTemPsy::Signal = oscPattern.signal,
--	oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature)=oscPattern.oscFeat, 
--	indAmp:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::a),
--	indP:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::w)
--	in
--		trace->select(t| 
--			trace->exists(t1,t2| 
--			trace->exists(t3,t4| 
--				 trace->exists(t5 | 
--					tl<= t1.generationTime and t1.generationTime < t2.generationTime and t2.generationTime< t3.generationTime and t3.generationTime < t4.generationTime
--				 	and t4.generationTime< t5.generationTime and t5.generationTime <=tu
--					and isOscillation(trace,t1,t2,t3,t4,t5,signal)
--				)
--			)
--		and t.generationTime=t1.generationTime
--		)
--		and peakToPeakAmp(subtrace,oscFeaturesList,indAmp,v1,v2,v3)
--		and period(trace,signal,oscFeaturesList,indP) 	
--		
--	)->first()
--
--
--def: getLastTimestampOfSatOscillationInNegation(trace:OrderedSet(trace::TraceElement),oscPattern:sBTemPsy::Oscillation,tl:Real,tu:Real):trace::TraceElement=
--	let 
--	signal:sBTemPsy::Signal = oscPattern.signal,
--	oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature)=oscPattern.oscFeat, 
--	indAmp:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::a),
--	indP:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::w)
--	in
--		trace->select(t| 
--			trace->exists(t1,t2| 
--			trace->exists(t3,t4| 
--				 trace->exists(t5 | 
--					tl<= t1.generationTime and t1.generationTime < t2.generationTime and t2.generationTime< t3.generationTime and t3.generationTime < t4.generationTime
--				 	and t4.generationTime< t5.generationTime and t5.generationTime <=tu
--					and isOscillation(trace,t1,t2,t3,t4,t5,signal)
--				and t.generationTime=t5.generationTime and t.generationTime > getFirstTimestampOfSatOscillationInNegation(trace,oscPattern,tl,tu).generationTime
--				)
--			)
--		)
--		and peakToPeakAmp(trace, signal,oscFeaturesList,indAmp) 
--		and period(trace,signal,oscFeaturesList,indP) 	
--		
--)->first()



def: getRTFirstValueInNegation(trace:OrderedSet(trace::TraceElement),rtPattern:sBTemPsy::Rise,tl:Real,tu:Real):trace::TraceElement=
	-- target: takes 1 if signal reaches the target value, 0 otherwise
	let result:Tuple(index:Integer, target:Integer, traceElement:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElement:trace::TraceElement) = Tuple{index:Integer=0 , target:Integer=0, traceElement:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  then 
	      if iter.target=0 and getValue(elem,rtPattern.signal).val < rtPattern.targetValue.val  then
	      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElement:trace::TraceElement=iter.traceElement}
	      else
		      	if iter.target=0 and getValue(elem,rtPattern.signal).val >= rtPattern.targetValue.val then
	  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1,traceElement:trace::TraceElement=elem} 
		      	else
		      		iter
		      endif
		  endif    
	else
			iter
	endif	      	 		     
) in result.traceElement


def: getFTFirstValueInNegation(trace:OrderedSet(trace::TraceElement),ftPattern:sBTemPsy::Fall,tl:Real,tu:Real):trace::TraceElement=
	let result:Tuple(index:Integer, target:Integer, traceElement:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElement:trace::TraceElement) = Tuple{index:Integer=0 , target:Integer=0, traceElement:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  then 
	      if iter.target=0 and getValue(elem,ftPattern.signal).val >= ftPattern.targetValue.val  then
	      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElement:trace::TraceElement=iter.traceElement}
	      else
		      	if iter.target=0 and getValue(elem,ftPattern.signal).val < ftPattern.targetValue.val then
	  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1,traceElement:trace::TraceElement=elem} 
		      	else
		      		iter
		      endif
		  endif    
	else
			iter
	endif	      	 		     
 ) in result.traceElement
	
def: getOSHFirstValueInNegation(trace:OrderedSet(trace::TraceElement),oshPattern:sBTemPsy::Overshoot,tl:Real,tu:Real):trace::TraceElement=
	-- target: takes 1 if signal reaches the target value, 0 otherwise
	let result:Tuple(index:Integer, target:Integer, traceElement:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElement:trace::TraceElement) = Tuple{index:Integer=0 , target:Integer=0, traceElement:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  and getValue(elem,oshPattern.signal).val <= oshPattern.targetValue.val+oshPattern.maximumValue.val then 
	      if iter.target=0 and getValue(elem,oshPattern.signal).val < oshPattern.targetValue.val  then
	      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElement:trace::TraceElement=iter.traceElement}
	      else
		      	if iter.target=0 and getValue(elem,oshPattern.signal).val >= oshPattern.targetValue.val then
	  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1,traceElement:trace::TraceElement=elem} 
		      	else
		      		iter
		      endif
		  endif    
	else
			iter
	endif	      	 		     
) in result.traceElement


def: getUSHFirstValueInNegation(trace:OrderedSet(trace::TraceElement),ushPattern:sBTemPsy::Undershoot,tl:Real,tu:Real):trace::TraceElement=
	-- target: takes 1 if signal reaches the target value, 0 otherwise
	let result:Tuple(index:Integer, target:Integer, traceElement:trace::TraceElement) = trace->iterate(elem:trace::TraceElement;
	  iter:Tuple(index:Integer,target:Integer, traceElement:trace::TraceElement) = Tuple{index:Integer=0 , target:Integer=0, traceElement:trace::TraceElement=trace->first()} -- it starts from the first index of the trace
	  | 
	let currentIndex:Integer = iter.index + 1 in	
	if  elem.generationTime >= tl and elem.generationTime < tu  and getValue(elem,ushPattern.signal).val >= ushPattern.targetValue.val-ushPattern.maximumValue.val.abs() then 
	      if iter.target=0 and getValue(elem,ushPattern.signal).val >= ushPattern.targetValue.val  then
	      	 Tuple{index:Integer = currentIndex, target:Integer=iter.target, traceElement:trace::TraceElement=iter.traceElement}
	      else
		      	if iter.target=0 and getValue(elem,ushPattern.signal).val < ushPattern.targetValue.val then
	  	 		 	Tuple{index:Integer = currentIndex, target:Integer=1,traceElement:trace::TraceElement=elem} 
		      	else
		      		iter
		      endif
		  endif    
	else
			iter
	endif	      	 		     
) in result.traceElement


---------------------------------------------
-- spike and oscillation checks in negation:
---------------------------------------------

---------------------------
-- spike in negation
---------------------------

def: getSpikeAmpDiagInfosInNegation(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Spike,tl:Real,tu:Real,spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature),indAmp:Integer):Sequence(Real)=
	let 
		result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfAmpl:Real,secondHalfAmpl:Real,spikeAmp:Real,firstExtTimeStamp:Real,satSpike:Integer,spikeAmpInfos:Sequence(Real)) = 
		subtrace->iterate(elem:trace::TraceElement; 
		  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfAmpl:Real,secondHalfAmpl:Real,spikeAmp:Real,firstExtTimeStamp:Real,satSpike:Integer,spikeAmpInfos:Sequence(Real)) = 
		  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,firstHalfAmpl:Real=0,secondHalfAmpl:Real=0,spikeAmp:Real=0,firstExtTimeStamp:Real=0,satSpike:Integer=0,spikeAmpInfos:Sequence(Real)=Sequence{0,0,0}} -- it starts from the first index of the trace
		  	|  --spikeAmpInfos is a sequence that returns 3 reals: the timestmap of the first extremum of the closest spike to satisfying the amplitude predicate, the timestamp of the last extremum of that spike and its amplitude:
		 let currentIndex:Integer = iter.index + 1,
		 	 lastSeenRec:trace::TraceElement=elem
		 in
	 if iter.satSpike=1 then		
	 		Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,firstExtTimeStamp:Real=iter.firstExtTimeStamp,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=iter.spikeAmpInfos} 
	else 
	 	-- iterate over all trace elements to return diagnostic information i-dp-spike-1:
	 		if iter.derivative=0 then
	 			-- if positive derivative:
	 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
	 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}} 
	 			-- if derivative is negative: 
 				else 
 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}} 
	 				else 
	 					-- case of flat signal:
	 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,firstExtTimeStamp:Real=iter.firstExtTimeStamp,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}					
	 				endif
	 			endif
	 		else 
	 			-- first extremum detected, missing strict local extremum
	 			if iter.derivative=1 then
		 			--1 case of strict maximum:  
					if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 		Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,spikeAmp:Real=iter.firstHalfAmpl.max(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val),firstExtTimeStamp:Real=iter.firstExtTimeStamp,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}				
	 				else -- signal still increasing:
	 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl+getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=iter.firstHalfAmpl+(getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val),firstExtTimeStamp:Real=iter.firstExtTimeStamp,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}				
	 					else 
	 					-- 2- case of strict minimum:
	 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 				Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,spikeAmp:Real=iter.firstHalfAmpl.max(getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val),firstExtTimeStamp:Real=iter.firstExtTimeStamp,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}				
	 						else 	-- signal still decreasing:
	 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=iter.firstHalfAmpl+getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=iter.firstHalfAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val),firstExtTimeStamp:Real=iter.firstExtTimeStamp,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}				
	 							else 	
	 								-- case of flat signal:
	 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=0,secondHalfAmpl:Real=0,spikeAmp:Real=0,firstExtTimeStamp:Real=0,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}	
	 							endif
	 						endif	
	 					endif
	 				endif
		 		else  -- case of derivative=2
	 			-- first extremum and first missing strict local extremum detected, missing last extremum:
					--1 case of local maximum: 
					if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
						if spikeAmpIsSat(iter.spikeAmp,pattern)=true then
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,satSpike:Integer=1,spikeAmpInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeAmp}}
						else 
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}
						endif
					else 
						--2 case of local minimum: 
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 							-- if the last seen spike is the closest to satisfying the amplitude-based predicate:
 							if spikeAmpIsSat(iter.spikeAmp,pattern)=true then
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,satSpike:Integer=1,spikeAmpInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeAmp}}
 							else 
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondHalfAmpl:Real=0,spikeAmp:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}
 							endif
						else 
							--3 case of flat signal:
 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
								--if the last seen spike is the closest to satisfying the amplitude-based predicate:
								if spikeAmpIsSat(iter.spikeAmp,pattern)=true then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,firstExtTimeStamp:Real=0,satSpike:Integer=1,spikeAmpInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeAmp}}
 								else 
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl,spikeAmp:Real=iter.spikeAmp,firstExtTimeStamp:Real=0,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}
 								endif
 							else 
 								-- signal still increasing or decreasing			
	 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfAmpl:Real=iter.firstHalfAmpl,secondHalfAmpl:Real=iter.secondHalfAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),spikeAmp:Real=iter.firstHalfAmpl.max(iter.secondHalfAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs()),firstExtTimeStamp:Real=iter.firstExtTimeStamp,satSpike:Integer=iter.satSpike,spikeAmpInfos:Sequence(Real)=Sequence{iter.spikeAmpInfos->at(1),iter.spikeAmpInfos->at(2),iter.spikeAmpInfos->at(3)}}	
	 						endif
		 				endif
	 				endif
	 			endif
	 		endif
	endif 	 	
	) in result.spikeAmpInfos


def: getSpikeWidthDiagInfosInNegation(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Spike,tl:Real,tu:Real,spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature),indW:Integer):Sequence(Real)=
	let 		
		result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfWidth:Real,secondHalfWidth:Real,spikeWidth:Real,firstExtTimeStamp:Real,spikeSat:Integer,spikeWidthInfos:Sequence(Real)) = 
		subtrace->iterate(elem:trace::TraceElement; 
		  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstHalfWidth:Real,secondHalfWidth:Real,spikeWidth:Real,firstExtTimeStamp:Real,spikeSat:Integer,spikeWidthInfos:Sequence(Real)) = 
		  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,firstExtTimeStamp:Real=0,spikeSat:Integer=0,spikeWidthInfos:Sequence(Real)=Sequence{0,0,0}} -- it starts from the first index of the trace
		  	|  --spikeWidthInfos is a sequence that returns 3 reals: the timestmap of the first extremum of the closest spike to satisfying the width predicate, the timestamp of the last extremum of that spike and its width:
		 let currentIndex:Integer = iter.index + 1,
		 	 lastSeenRec:trace::TraceElement=elem
		 in
	 if iter.spikeSat=1 then		
	 		Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=iter.secondHalfWidth,spikeWidth:Real=iter.spikeWidth, firstExtTimeStamp:Real=iter.firstExtTimeStamp,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=iter.spikeWidthInfos} 
	else 
	
	 	-- iterate over all trace elements to return diagnostic information i-dp-spike-1:
	 		if iter.derivative=0 then
	 			-- if positive derivative:
	 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
	 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}} 
	 			-- if derivative is negative: 
 				else 
 					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}} 
	 				else 
	 					-- case of flat signal:
	 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=iter.secondHalfWidth,spikeWidth:Real=iter.spikeWidth,firstExtTimeStamp:Real=iter.firstExtTimeStamp,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}					
	 				endif
	 			endif
	 		else 
	 			-- first extremum detected, missing strict local extremum
	 			if iter.derivative=1 then
		 			--1 case of strict maximum:  
					if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 		Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,spikeWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),firstExtTimeStamp:Real=iter.firstExtTimeStamp,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}				
	 				else -- signal still increasing:
	 					if iter.up=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 			Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),secondHalfWidth:Real=0,spikeWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),firstExtTimeStamp:Real=iter.firstExtTimeStamp,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}				
	 					else 
	 					-- 2- case of strict minimum:
	 						if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then
				 				Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,spikeWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),firstExtTimeStamp:Real=iter.firstExtTimeStamp,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}				
	 						else 	-- signal still decreasing:
	 							if iter.down=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then
				 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),secondHalfWidth:Real=0,spikeWidth:Real=iter.firstHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),firstExtTimeStamp:Real=iter.firstExtTimeStamp,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}				
	 							else 	
	 								-- case of flat signal:
	 								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,firstExtTimeStamp:Real=0,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}	
	 							endif
	 						endif	
	 					endif
	 				endif
		 		else  -- case of derivative=2
	 			-- first extremum and first missing strict local extremum detected, missing last extremum:
					--1 case of local maximum: 
					if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
						-- if the last seen spike is the closest to satisfying the width-based predicate:
						if spikeWidthIsSat(iter.spikeWidth,pattern)=true then
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,spikeSat:Integer=1,spikeWidthInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeWidth}}
						else 
							Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}
						endif
					else 
						--2 case of local minimum: 
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 							-- if the last seen spike is the closest to satisfying the width-based predicate:
 							if spikeWidthIsSat(iter.spikeWidth,pattern)=true then
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,spikeSat:Integer=1,spikeWidthInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeWidth}}
 							else 
 								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstHalfWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,secondHalfWidth:Real=0,spikeWidth:Real=elem.generationTime-iter.lastSeenRecord.generationTime,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}
 							endif
						else 
							--3 case of flat signal:
 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
								--if the last seen spike is the closest to satisfying the width-based predicate:
								if spikeWidthIsSat(iter.spikeWidth,pattern)=true then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,firstExtTimeStamp:Real=0,spikeSat:Integer=1,spikeWidthInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,iter.lastSeenRecord.generationTime,iter.spikeWidth}}
 								else 
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstHalfWidth:Real=0,secondHalfWidth:Real=0,spikeWidth:Real=0,firstExtTimeStamp:Real=0,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}
 								endif
 							else 
 								-- signal still increasing or decreasing			
	 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstHalfWidth:Real=iter.firstHalfWidth,secondHalfWidth:Real=iter.secondHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime),spikeWidth:Real=iter.firstHalfWidth+(iter.secondHalfWidth+(elem.generationTime-iter.lastSeenRecord.generationTime)),firstExtTimeStamp:Real=iter.firstExtTimeStamp,spikeSat:Integer=iter.spikeSat,spikeWidthInfos:Sequence(Real)=Sequence{iter.spikeWidthInfos->at(1),iter.spikeWidthInfos->at(2),iter.spikeWidthInfos->at(3)}}	
	 						endif
		 				endif
	 				endif
	 			endif
	 		endif
	 endif	 	
) in result.spikeWidthInfos -- diagnostic information for the closest spike to the satisfaction of the spike-based predicate

---------------------------
-- oscillations in negation
---------------------------
def: p2pDiagnosticInformationInNegation(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real,oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature),indAmp:Integer):Sequence(Real)=
	let 
	result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstOscAmpl:Real,secondOscAmpl:Real,firstExtTimeStamp:Real,oscSat:Integer,oscp2pInfos:Sequence(Real)) = 
	subtrace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,firstOscAmpl:Real,secondOscAmpl:Real,firstExtTimeStamp:Real,oscSat:Integer,oscp2pInfos:Sequence(Real)) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=0,oscSat:Integer=0,oscp2pInfos:Sequence(Real)=Sequence{0,0,0}} -- it starts from the first index of the trace
	  	| 																																																				
	let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	in

	if iter.oscSat=1 then
		Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.firstExtTimeStamp,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
	else
 		-- iterate over all trace elements to check dp-oscillation-1
 		if iter.derivative=0 then
 			-- if positive derivative:
 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=Sequence{iter.lastSeenRecord.generationTime,iter.oscp2pInfos->at(2),iter.oscp2pInfos->at(3)}} 
 			-- if derivative is negative: 
			else 
				if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
					Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=Sequence{iter.lastSeenRecord.generationTime,iter.oscp2pInfos->at(2),iter.oscp2pInfos->at(3)}} 
 				else 
 					-- case of flat signal:
 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.firstExtTimeStamp,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=Sequence{iter.oscp2pInfos->at(1),iter.oscp2pInfos->at(2),iter.oscp2pInfos->at(3)}}					
 				endif
 			endif
 		else  
 			-- first extremum and first missing strict local extremum detected, missing last extremum:
				if iter.derivative=1 then	
					--1 case of local maximum: 
					if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
						Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=getValue(elem,pattern.signal).val-getValue(iter.lastSeenRecord,pattern.signal).val,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.firstExtTimeStamp,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
					else 
						--2 case of local minimum: 
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 								Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val,secondOscAmpl:Real=0,firstExtTimeStamp:Real=iter.firstExtTimeStamp,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
						else 
							--3 case of flat signal:
 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
								Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=0,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
 							else 
 								-- signal still increasing or decreasing			
	 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.firstExtTimeStamp,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}		
	 						endif
		 				endif
	 				endif
	 			else --iter.derivative=2, missing last strict extremum
	 				if iter.derivative=2 then		
		 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
							Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),firstExtTimeStamp:Real=iter.firstExtTimeStamp,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
						else 
							--2 case of local minimum: 
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
								Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),firstExtTimeStamp:Real=iter.firstExtTimeStamp,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
							else 
								--3 case of flat signal:
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=0,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
	 							else 
	 								-- signal still increasing or decreasing			
		 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.firstExtTimeStamp,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}	
		 						endif
			 				endif
		 				endif
	 				else  
	 					--if iter.derivative=3 then		
		 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
		 					-- if the amplitude predicate is satisfied
		 					if oscAmpIsSat(iter.firstOscAmpl,pattern)=true and oscAmpIsSat(iter.secondOscAmpl,pattern)=true then
								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,oscSat:Integer=1,oscp2pInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,elem.generationTime,iter.firstOscAmpl.max(iter.secondOscAmpl)}}
							else
								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
							endif	
						else 
							--2 case of local minimum: 
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
			 					if oscAmpIsSat(iter.firstOscAmpl,pattern)=true and oscAmpIsSat(iter.secondOscAmpl,pattern)=true then
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,oscSat:Integer=1,oscp2pInfos:Sequence(Real)=Sequence{iter.firstExtTimeStamp,elem.generationTime,iter.firstOscAmpl.max(iter.secondOscAmpl)}}
								else
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl,firstExtTimeStamp:Real=iter.lastSeenRecord.generationTime,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
								endif	
							else 
								--3 case of flat signal: --no oscillation
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,firstOscAmpl:Real=0,secondOscAmpl:Real=0,firstExtTimeStamp:Real=0,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}
	 							else 
	 								-- signal still increasing or decreasing, recomputing the updated amplitude			
		 								Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,firstOscAmpl:Real=iter.firstOscAmpl,secondOscAmpl:Real=iter.secondOscAmpl+(getValue(iter.lastSeenRecord,pattern.signal).val-getValue(elem,pattern.signal).val).abs(),firstExtTimeStamp:Real=iter.firstExtTimeStamp,oscSat:Integer=iter.oscSat,oscp2pInfos:Sequence(Real)=iter.oscp2pInfos}			
		 						endif
			 				endif
		 				endif
	 				endif
	 			endif
 			endif 	
		endif
	) in result.oscp2pInfos -- diagnostic information about the satisfied oscillation-based property
		
def: periodDiagnosticInformationInNegation(subtrace:OrderedSet(trace::TraceElement), pattern:sBTemPsy::Oscillation,tl:Real,tu:Real,oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature),indP:Integer):Sequence(Real)=
	let 
	periodThreshold:Real=oscFeaturesList->at(indP).oscFPred.value.val,
	result:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,oscPeriod:Real,oscSat:Integer,firstDetectedExt:Real,diagInfos:Sequence(Real)) = 
	subtrace->iterate(elem:trace::TraceElement; 
	  iter:Tuple(index:Integer,derivative:Real,lastSeenRecord:trace::TraceElement,up:Integer,down:Integer,oscPeriod:Real,oscSat:Integer,firstDetectedExt:Real,diagInfos:Sequence(Real)) = 
	  	Tuple{index:Integer=0,derivative:Real=0, lastSeenRecord:trace::TraceElement=subtrace->first(),up:Integer=0,down:Integer=0,oscPeriod:Real=0,oscSat:Integer=0,firstDetectedExt:Real=0,diagInfos:Sequence(Real)=Sequence{0,0,0}} -- it starts from the first index of the trace
	  	| 
	let currentIndex:Integer = iter.index + 1,
	 	 lastSeenRec:trace::TraceElement=elem 
	in
	if iter.oscSat=1 then
 		Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
	else
 		-- iterate over all trace elements to check dp-oscillation-1
 		if iter.derivative=0 then
 			-- if positive derivative:
 			if getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
 				Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=0,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=iter.diagInfos} 
 			-- if derivative is negative: 
				else 
					if getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
						Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=0,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=iter.diagInfos} 
 				else 
 					-- case of flat signal:
 					Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=0,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}					
 				endif
 			endif
 		else  
 			-- first extremum and first missing strict local extremum detected, missing last extremum:
				if iter.derivative=1 then	
					--1 case of local maximum: 
					if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
						Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=elem.generationTime-iter.lastSeenRecord.generationTime,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
					else 
						--2 case of local minimum: 
						if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 								Tuple{index:Integer=currentIndex, derivative:Real=2, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=elem.generationTime-iter.lastSeenRecord.generationTime,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
						else 
							--3 case of flat signal:
 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=0,diagInfos:Sequence(Real)=iter.diagInfos}
 							else 
 								-- signal still increasing or decreasing			
	 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}		
	 						endif
		 				endif
	 				endif
	 			else --iter.derivative=2, missing last strict extremum
	 				if iter.derivative=2 then		
		 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
							Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
						else 
							--2 case of local minimum: 
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
								Tuple{index:Integer=currentIndex, derivative:Real=3, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
							else 
								--3 case of flat signal:
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=0,diagInfos:Sequence(Real)=iter.diagInfos}
	 							else 
	 								-- signal still increasing or decreasing			
		 							Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}	
		 						endif
			 				endif
		 				endif
	 				else  
	 					--if iter.derivative=3 then		
		 				if iter.down=1 and getValue(elem,pattern.signal).val > getValue(iter.lastSeenRecord,pattern.signal).val then 
		 					-- if the current oscillation is the closest to satisfying the period predicate
		 					if oscPeriodIsSat(iter.oscPeriod,pattern)=true then 
								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=iter.oscPeriod,oscSat:Integer=1,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=Sequence{iter.firstDetectedExt,elem.generationTime,iter.oscPeriod}}
							else
								Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=1,down:Integer=0,oscPeriod:Real=iter.oscPeriod,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=iter.diagInfos}
							endif	
						else 
							--2 case of local minimum: 
							-- if the current oscillation is the closest to satisfying the period predicate
							if iter.up=1 and getValue(elem,pattern.signal).val < getValue(iter.lastSeenRecord,pattern.signal).val then 
 								if oscPeriodIsSat(iter.oscPeriod,pattern)=true then 
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=iter.oscPeriod,oscSat:Integer=1,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=Sequence{iter.firstDetectedExt,elem.generationTime,iter.oscPeriod}}
								else
									Tuple{index:Integer=currentIndex, derivative:Real=1, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=1,oscPeriod:Real=iter.oscPeriod,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.lastSeenRecord.generationTime,diagInfos:Sequence(Real)=iter.diagInfos}
								endif	
							else 
								--3 case of flat signal: --no oscillation
	 							if getValue(elem,pattern.signal).val = getValue(iter.lastSeenRecord,pattern.signal).val then
 									Tuple{index:Integer=currentIndex, derivative:Real=0, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=0,down:Integer=0,oscPeriod:Real=0,oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}
	 							else 
	 								-- signal still increasing or decreasing, recomputing the updated period			
	 								Tuple{index:Integer=currentIndex, derivative:Real=iter.derivative, lastSeenRecord:trace::TraceElement=lastSeenRec,up:Integer=iter.up,down:Integer=iter.down,oscPeriod:Real=iter.oscPeriod+(elem.generationTime-iter.lastSeenRecord.generationTime),oscSat:Integer=iter.oscSat,firstDetectedExt:Real=iter.firstDetectedExt,diagInfos:Sequence(Real)=iter.diagInfos}			
		 						endif
			 				endif
		 				endif
	 				endif
	 			endif
 			endif 
		endif		
	) in result.diagInfos 


def: reportNegation(trace:OrderedSet(trace::TraceElement),negProperty:sBTemPsy::AbstractProperty):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	let	simpleProperty:sBTemPsy::Property=negProperty.oclAsType(sBTemPsy::Property),
		tl:Real=trace->first().generationTime, tu:Real=trace->last().generationTime,
		scope:sBTemPsy::Scope=simpleProperty.scope.oclAsType(sBTemPsy::Scope),
		pattern:sBTemPsy::SimplePattern=simpleProperty.pattern.oclAsType(sBTemPsy::SimplePattern) 
	in
			if ( (scope.oclIsTypeOf(sBTemPsy::Before) and scope.oclAsType(sBTemPsy::Before).boundary.eventB <> null) or
				(scope.oclIsTypeOf(sBTemPsy::After) and scope.oclAsType(sBTemPsy::After).boundary.eventB <> null) or
				(scope.oclIsTypeOf(sBTemPsy::BetweenAnd) and scope.oclAsType(sBTemPsy::BetweenAnd).boundary1.eventB <> null and scope.oclAsType(sBTemPsy::BetweenAnd).boundary2.eventB <> null) or
				(simpleProperty.pattern.oclIsTypeOf(sBTemPsy::Order))
			   )
			 then 
				Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}} -- if no records in the trace --return nothing for universal quantifier-based semantics for event-based scope boundaries and order pattern
			else
				if simpleProperty.pattern.oclIsTypeOf(sBTemPsy::DataAssertion) and simpleProperty.pattern.oclIsTypeOf(sBTemPsy::DataAssertion).oclIsTypeOf(sBTemPsy::StateAssertion) then 
					let assertion:sBTemPsy::StateAssertion= simpleProperty.pattern.oclIsTypeOf(sBTemPsy::DataAssertion).oclAsType(sBTemPsy::StateAssertion) in	
					Set{Tuple{vSignal:String=assertion.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))=Sequence{Tuple{timestamp:Real=reportStateInNegation(trace,assertion,tl,tu).generationTime,signalValue:Real=getValue(reportStateInNegation(trace,assertion,tl,tu),assertion.signal).val}},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::i_becomes}} 	
				else 
					if  simpleProperty.pattern.oclIsTypeOf(sBTemPsy::Spike) then
						let spkPattern:sBTemPsy::Spike= simpleProperty.pattern.oclAsType(sBTemPsy::Spike),
						spikeFeaturesList:OrderedSet(sBTemPsy::SpikeFeature)=spkPattern.spkFeat
						 in	
								-- if amplitude-based predicate
								if spikeFeaturesList.spkFName->includes(sBTemPsy::SpikeFeatureName::a) then 
								let indAmp:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::a) in
								Set{Tuple{vSignal:String=spkPattern.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))=
									Sequence{},
									Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
									Tuple{leftBound:Real=getSpikeAmpDiagInfosInNegation(trace,spkPattern,tl,tu,spikeFeaturesList,indAmp)->at(1),
								  		  rightBound:Real=getSpikeAmpDiagInfosInNegation(trace,spkPattern,tl,tu,spikeFeaturesList,indAmp)->at(2),
								  		  recordValue:Sequence(Real)=Sequence{getSpikeAmpDiagInfosInNegation(trace,spkPattern,tl,tu,spikeFeaturesList,indAmp)->at(3)}
								  		},
							  		violationType=diagnostics::ViolationType::i_spike
								}} 
								else -- if width-based predicate 
									let indW:Integer=spikeFeaturesList.spkFName->indexOf(sBTemPsy::SpikeFeatureName::w) in
									Set{Tuple{vSignal:String=spkPattern.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))=
										Sequence{},
										Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
										Tuple{leftBound:Real=getSpikeWidthDiagInfosInNegation(trace,spkPattern,tl,tu,spikeFeaturesList,indW)->at(1),
								  		  rightBound:Real=getSpikeWidthDiagInfosInNegation(trace,spkPattern,tl,tu,spikeFeaturesList,indW)->at(2),
								  		  recordValue:Sequence(Real)=Sequence{getSpikeWidthDiagInfosInNegation(trace,spkPattern,tl,tu,spikeFeaturesList,indW)->at(3)}
								  		},
								  		violationType=diagnostics::ViolationType::i_spike
										}} 
								endif							
					else
					 	if  simpleProperty.pattern.oclIsTypeOf(sBTemPsy::Oscillation) then
	 							let oscPattern:sBTemPsy::Oscillation= simpleProperty.pattern.oclAsType(sBTemPsy::Oscillation),
	 							oscFeaturesList:OrderedSet(sBTemPsy::OscillationsFeature)=oscPattern.oscFeat
	 							 in	
						 		-- if p2p-based predicate
						 		if oscFeaturesList.oscFName->includes(sBTemPsy::OscillationsFeatureName::a) then 
						 			let indp2p:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::a) in
							 		Set{Tuple{vSignal:String=oscPattern.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))=
										Sequence{},
										Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
										Tuple{leftBound:Real=p2pDiagnosticInformationInNegation(trace,oscPattern,tl,tu,oscFeaturesList,indp2p)->at(1),
									  		  rightBound:Real=p2pDiagnosticInformationInNegation(trace,oscPattern,tl,tu,oscFeaturesList,indp2p)->at(2),
									  		  recordValue:Sequence(Real)=Sequence{p2pDiagnosticInformationInNegation(trace,oscPattern,tl,tu,oscFeaturesList,indp2p)->at(3)}
									  		},
										violationType=diagnostics::ViolationType::i_oscillation
										}}
					 			-- else, if period-based predicate
					 			else 
					 					let indP:Integer=oscFeaturesList.oscFName->indexOf(sBTemPsy::OscillationsFeatureName::w) in
					 					Set{Tuple{vSignal:String=oscPattern.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))=
										Sequence{},
										Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=
										Tuple{leftBound:Real=periodDiagnosticInformationInNegation(trace,oscPattern,tl,tu,oscFeaturesList,indP)->at(1),
									  		  rightBound:Real=periodDiagnosticInformationInNegation(trace,oscPattern,tl,tu,oscFeaturesList,indP)->at(2),
									  		  recordValue:Sequence(Real)=Sequence{periodDiagnosticInformationInNegation(trace,oscPattern,tl,tu,oscFeaturesList,indP)->at(3)}
									  		},
										violationType=diagnostics::ViolationType::i_oscillation
										}}
					 			endif
					 	else
					 		if simpleProperty.pattern.oclIsTypeOf(sBTemPsy::Rise) then
 								let rtPattern:sBTemPsy::Rise= simpleProperty.pattern.oclAsType(sBTemPsy::Rise) in
 								Set{Tuple{vSignal:String=rtPattern.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))=
								Sequence{
									Tuple{timestamp:Real=getRTFirstValueInNegation(trace,rtPattern,tl,tu).generationTime,signalValue:Real=getValue(getRTFirstValueInNegation(trace,rtPattern,tl,tu),rtPattern.signal).val}
										},
								Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::i_rises
								}}
 							else 
 								if simpleProperty.pattern.oclIsTypeOf(sBTemPsy::Fall) then
 									let fallPattern:sBTemPsy::Fall= simpleProperty.pattern.oclAsType(sBTemPsy::Fall) in
 									Set{Tuple{vSignal:String=fallPattern.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))=
										Sequence{
											Tuple{timestamp:Real=getFTFirstValueInNegation(trace,fallPattern,tl,tu).generationTime,signalValue:Real=getValue(getFTFirstValueInNegation(trace,fallPattern,tl,tu),fallPattern.signal).val}
												},
										Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::i_falls
										}}
 								else 
 									if simpleProperty.pattern.oclIsTypeOf(sBTemPsy::Overshoot) then
		 								let oshPattern:sBTemPsy::Overshoot= simpleProperty.pattern.oclAsType(sBTemPsy::Overshoot) in
		 								Set{Tuple{vSignal:String=oshPattern.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))=
										Sequence{
											Tuple{timestamp:Real=getOSHFirstValueInNegation(trace,oshPattern,tl,tu).generationTime,signalValue:Real=getValue(getOSHFirstValueInNegation(trace,oshPattern,tl,tu),oshPattern.signal).val}
												},
										Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::i_overshoots
											}}
		 							else
		 								if simpleProperty.pattern.oclIsTypeOf(sBTemPsy::Undershoot) then
			 								let ushPattern:sBTemPsy::Undershoot= simpleProperty.pattern.oclAsType(sBTemPsy::Undershoot) in
			 								Set{Tuple{vSignal:String=ushPattern.signal.id,Records:Sequence(Tuple(timestamp:Real,signalValue:Real))=
											Sequence{
												Tuple{timestamp:Real=getUSHFirstValueInNegation(trace,ushPattern,tl,tu).generationTime,signalValue:Real=getValue(getUSHFirstValueInNegation(trace,ushPattern,tl,tu),ushPattern.signal).val}
													},
											Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::i_undershoots
											}}
			 							else 
			 								Set{Tuple{vSignal:String='',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}} 

			 							endif		
		 							endif 
 								endif	
 							endif		
					 	endif		
					 endif	 
				endif				
			endif	
		

def: reportProperty(trace:OrderedSet(trace::TraceElement),property:sBTemPsy::AbstractProperty):Set(Tuple(vSignal:String,Records:Sequence(Tuple(timestamp:Real,signalValue:Real)),Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real)),violationType:diagnostics::ViolationType))=
	if trace->isEmpty() then 
		Set{Tuple{vSignal:String='Empty trace',Records:Sequence(Tuple(timestamp:Real,signalValue:Real))= Sequence{},Interval:Tuple(leftBound:Real,rightBound:Real,recordValue:Sequence(Real))=null,violationType=diagnostics::ViolationType::NotSupported}} -- if no records in the trace
	else
	if property.oclIsTypeOf(sBTemPsy::AndProperty) then  
				-- for conjunction, we report information about the violated property
				let andProperty:sBTemPsy::AndProperty = property.oclAsType(sBTemPsy::AndProperty), 
				andProOne:sBTemPsy::AbstractProperty = andProperty.property1,
				andProTwo:sBTemPsy::AbstractProperty = andProperty.property2
			in
				-- and
				if (checkProperty(trace, andProOne)=false and checkProperty(trace, andProTwo)=true)  then 
					reportProperty(trace, andProOne)
				else
				
					if (checkProperty(trace, andProOne)=true and checkProperty(trace, andProTwo)=false)  then 
						reportProperty(trace, andProTwo)

					else
						reportProperty(trace, andProOne)->union(reportProperty(trace, andProTwo))--union
					endif
				endif	
	else
			if property.oclIsTypeOf(sBTemPsy::OrProperty) then  
				let orProperty:sBTemPsy::OrProperty = property.oclAsType(sBTemPsy::OrProperty), 
					orProOne:sBTemPsy::AbstractProperty = orProperty.property1,
					orProTwo:sBTemPsy::AbstractProperty = orProperty.property2
				in
				-- for disjunction, the two properties lead to the property violation, so we report information about the first one 
				if (checkProperty(trace, property)=false)  then 
					-- the two conditions are false, so I report violation information about the two of them
					reportProperty(trace, orProOne)->union(reportProperty(trace, orProTwo))--union
				else 
					null 
				endif					
			else  
				-- negation	
				if property.oclIsTypeOf(sBTemPsy::NotProperty) then 
					let negProp:sBTemPsy::NotProperty = property.oclAsType(sBTemPsy::NotProperty) in 
--						if checkProperty(trace,negProp)=false then --useless condition
							reportNegation(trace,negProp.property)					
--						else
--						 	null
--						 endif							
				else -- one simple property case
					let simpleProperty:sBTemPsy::Property=property.oclAsType(sBTemPsy::Property) in
						reportSimpleProperty(trace,simpleProperty)
			
				endif
		   endif
  endif
endif
	
		 		
			
endpackage


